<!DOCTYPE HTML>
<html lang="en" class="navy" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>iOS Interview Mastery: 100 Questions to Win</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Master iOS interviews with 100 essential questions, quizzes, and hands-on coding challenges">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('navy')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="flashcards.html">üé¥ Flashcards - All 70 Questions</a></li><li class="chapter-item expanded affix "><li class="part-title">Swift & Language (1-20)</li><li class="chapter-item expanded "><a href="swift/01-struct-vs-class.html"><strong aria-hidden="true">1.</strong> Q1: Struct vs Class</a></li><li class="chapter-item expanded "><a href="swift/02-value-vs-reference.html"><strong aria-hidden="true">2.</strong> Q2: Value vs Reference Types</a></li><li class="chapter-item expanded "><a href="swift/03-arc-basics.html"><strong aria-hidden="true">3.</strong> Q3: How ARC Works</a></li><li class="chapter-item expanded "><a href="swift/04-reference-types.html"><strong aria-hidden="true">4.</strong> Q4: Strong, Weak, Unowned</a></li><li class="chapter-item expanded "><a href="swift/05-retain-cycles.html"><strong aria-hidden="true">5.</strong> Q5: Retain Cycles</a></li><li class="chapter-item expanded "><a href="swift/06-property-wrappers.html"><strong aria-hidden="true">6.</strong> Q6: Property Wrappers</a></li><li class="chapter-item expanded "><a href="swift/07-codable.html"><strong aria-hidden="true">7.</strong> Q7: Codable</a></li><li class="chapter-item expanded "><a href="swift/08-map-functions.html"><strong aria-hidden="true">8.</strong> Q8: Map, FlatMap, CompactMap</a></li><li class="chapter-item expanded "><a href="swift/09-generics.html"><strong aria-hidden="true">9.</strong> Q9: Generics</a></li><li class="chapter-item expanded "><a href="swift/10-protocols.html"><strong aria-hidden="true">10.</strong> Q10: Protocols</a></li><li class="chapter-item expanded "><a href="swift/11-protocol-vs-class.html"><strong aria-hidden="true">11.</strong> Q11: Protocol vs Class Inheritance</a></li><li class="chapter-item expanded "><a href="swift/12-associated-types.html"><strong aria-hidden="true">12.</strong> Q12: Associated Types</a></li><li class="chapter-item expanded "><a href="swift/13-extensions.html"><strong aria-hidden="true">13.</strong> Q13: Extensions</a></li><li class="chapter-item expanded "><a href="swift/14-static-vs-class.html"><strong aria-hidden="true">14.</strong> Q14: Static vs Class Methods</a></li><li class="chapter-item expanded "><a href="swift/15-closures.html"><strong aria-hidden="true">15.</strong> Q15: Closures</a></li><li class="chapter-item expanded "><a href="swift/16-escaping-closures.html"><strong aria-hidden="true">16.</strong> Q16: Escaping vs Non-Escaping</a></li><li class="chapter-item expanded "><a href="swift/17-autoclosure.html"><strong aria-hidden="true">17.</strong> Q17: Autoclosure</a></li><li class="chapter-item expanded "><a href="swift/18-inout.html"><strong aria-hidden="true">18.</strong> Q18: Inout</a></li><li class="chapter-item expanded "><a href="swift/19-optional-chaining.html"><strong aria-hidden="true">19.</strong> Q19: Optional Chaining</a></li><li class="chapter-item expanded "><a href="swift/20-properties.html"><strong aria-hidden="true">20.</strong> Q20: Computed vs Stored Properties</a></li><li class="chapter-item expanded affix "><li class="part-title">Concurrency (21-30)</li><li class="chapter-item expanded "><a href="concurrency/21-gcd.html"><strong aria-hidden="true">21.</strong> Q21: GCD</a></li><li class="chapter-item expanded "><a href="concurrency/22-sync-async.html"><strong aria-hidden="true">22.</strong> Q22: Sync vs Async</a></li><li class="chapter-item expanded "><a href="concurrency/23-queues.html"><strong aria-hidden="true">23.</strong> Q23: Serial vs Concurrent Queues</a></li><li class="chapter-item expanded "><a href="concurrency/24-race-conditions.html"><strong aria-hidden="true">24.</strong> Q24: Race Conditions</a></li><li class="chapter-item expanded "><a href="concurrency/25-deadlocks.html"><strong aria-hidden="true">25.</strong> Q25: Deadlocks</a></li><li class="chapter-item expanded "><a href="concurrency/26-dispatch-group.html"><strong aria-hidden="true">26.</strong> Q26: DispatchGroup</a></li><li class="chapter-item expanded "><a href="concurrency/27-operation-queue.html"><strong aria-hidden="true">27.</strong> Q27: OperationQueue</a></li><li class="chapter-item expanded "><a href="concurrency/28-async-await.html"><strong aria-hidden="true">28.</strong> Q28: Async-Await</a></li><li class="chapter-item expanded "><a href="concurrency/29-actors.html"><strong aria-hidden="true">29.</strong> Q29: Actors</a></li><li class="chapter-item expanded "><a href="concurrency/30-main-actor.html"><strong aria-hidden="true">30.</strong> Q30: MainActor</a></li><li class="chapter-item expanded affix "><li class="part-title">Memory Management (31-40)</li><li class="chapter-item expanded "><a href="memory/31-arc-allocation.html"><strong aria-hidden="true">31.</strong> Q31: ARC Memory Allocation</a></li><li class="chapter-item expanded "><a href="memory/32-weak-references.html"><strong aria-hidden="true">32.</strong> Q32: Weak References</a></li><li class="chapter-item expanded "><a href="memory/33-unowned-references.html"><strong aria-hidden="true">33.</strong> Q33: Unowned References</a></li><li class="chapter-item expanded "><a href="memory/34-closure-cycles.html"><strong aria-hidden="true">34.</strong> Q34: Closure Retain Cycles</a></li><li class="chapter-item expanded "><a href="memory/35-capture-lists.html"><strong aria-hidden="true">35.</strong> Q35: Capture Lists</a></li><li class="chapter-item expanded "><a href="memory/36-memory-leaks.html"><strong aria-hidden="true">36.</strong> Q36: Memory Leaks</a></li><li class="chapter-item expanded "><a href="memory/37-instruments.html"><strong aria-hidden="true">37.</strong> Q37: Instruments</a></li><li class="chapter-item expanded "><a href="memory/38-mvvm-cycles.html"><strong aria-hidden="true">38.</strong> Q38: MVVM Retain Cycles</a></li><li class="chapter-item expanded "><a href="memory/39-memory-warnings.html"><strong aria-hidden="true">39.</strong> Q39: Memory Warnings</a></li><li class="chapter-item expanded "><a href="memory/40-reference-counting.html"><strong aria-hidden="true">40.</strong> Q40: Reference Counting</a></li><li class="chapter-item expanded affix "><li class="part-title">UIKit & SwiftUI (41-60)</li><li class="chapter-item expanded "><a href="ui/41-viewcontroller-lifecycle.html"><strong aria-hidden="true">41.</strong> Q41: UIViewController Lifecycle</a></li><li class="chapter-item expanded "><a href="ui/42-app-lifecycle.html"><strong aria-hidden="true">42.</strong> Q42: App Lifecycle</a></li><li class="chapter-item expanded "><a href="ui/43-frame-bounds.html"><strong aria-hidden="true">43.</strong> Q43: Frame vs Bounds</a></li><li class="chapter-item expanded "><a href="ui/44-auto-layout.html"><strong aria-hidden="true">44.</strong> Q44: Auto Layout</a></li><li class="chapter-item expanded "><a href="ui/45-constraints-frames.html"><strong aria-hidden="true">45.</strong> Q45: Constraints vs Frames</a></li><li class="chapter-item expanded "><a href="ui/46-cell-reuse.html"><strong aria-hidden="true">46.</strong> Q46: Cell Reuse</a></li><li class="chapter-item expanded "><a href="ui/47-diffable-data-source.html"><strong aria-hidden="true">47.</strong> Q47: Diffable Data Source</a></li><li class="chapter-item expanded "><a href="ui/48-compositional-layout.html"><strong aria-hidden="true">48.</strong> Q48: Compositional Layout</a></li><li class="chapter-item expanded "><a href="ui/49-swiftui-lifecycle.html"><strong aria-hidden="true">49.</strong> Q49: SwiftUI Lifecycle</a></li><li class="chapter-item expanded "><a href="ui/50-state-binding.html"><strong aria-hidden="true">50.</strong> Q50: @State vs @Binding</a></li><li class="chapter-item expanded "><a href="ui/51-observed-state-object.html"><strong aria-hidden="true">51.</strong> Q51: @ObservedObject vs @StateObject</a></li><li class="chapter-item expanded "><a href="ui/52-environment.html"><strong aria-hidden="true">52.</strong> Q52: Environment Values</a></li><li class="chapter-item expanded "><a href="ui/53-navigation-stack.html"><strong aria-hidden="true">53.</strong> Q53: NavigationStack</a></li><li class="chapter-item expanded "><a href="ui/54-diff-engine.html"><strong aria-hidden="true">54.</strong> Q54: SwiftUI Diff Engine</a></li><li class="chapter-item expanded "><a href="ui/55-view-identity.html"><strong aria-hidden="true">55.</strong> Q55: View Identity</a></li><li class="chapter-item expanded "><a href="ui/56-lazy-stacks.html"><strong aria-hidden="true">56.</strong> Q56: Lazy Stacks</a></li><li class="chapter-item expanded "><a href="ui/57-scroll-performance.html"><strong aria-hidden="true">57.</strong> Q57: Scroll Performance</a></li><li class="chapter-item expanded "><a href="ui/58-rendering-pipeline.html"><strong aria-hidden="true">58.</strong> Q58: Rendering Pipeline</a></li><li class="chapter-item expanded "><a href="ui/59-uikit-swiftui.html"><strong aria-hidden="true">59.</strong> Q59: UIKit vs SwiftUI</a></li><li class="chapter-item expanded "><a href="ui/60-mixing-frameworks.html"><strong aria-hidden="true">60.</strong> Q60: Mixing UIKit + SwiftUI</a></li><li class="chapter-item expanded affix "><li class="part-title">Networking (61-70)</li><li class="chapter-item expanded "><a href="networking/61-urlsession.html"><strong aria-hidden="true">61.</strong> Q61: URLSession Flow</a></li><li class="chapter-item expanded "><a href="networking/62-tasks.html"><strong aria-hidden="true">62.</strong> Q62: DataTask vs DownloadTask</a></li><li class="chapter-item expanded "><a href="networking/63-json-decoding.html"><strong aria-hidden="true">63.</strong> Q63: JSON Decoding</a></li><li class="chapter-item expanded "><a href="networking/64-error-handling.html"><strong aria-hidden="true">64.</strong> Q64: Error Handling</a></li><li class="chapter-item expanded "><a href="networking/65-caching.html"><strong aria-hidden="true">65.</strong> Q65: HTTP Caching</a></li><li class="chapter-item expanded "><a href="networking/66-url-requests.html"><strong aria-hidden="true">66.</strong> Q66: URLRequests</a></li><li class="chapter-item expanded "><a href="networking/67-rest-graphql.html"><strong aria-hidden="true">67.</strong> Q67: REST vs GraphQL</a></li><li class="chapter-item expanded "><a href="networking/68-status-codes.html"><strong aria-hidden="true">68.</strong> Q68: Status Codes</a></li><li class="chapter-item expanded "><a href="networking/69-retry.html"><strong aria-hidden="true">69.</strong> Q69: Retry Mechanism</a></li><li class="chapter-item expanded "><a href="networking/70-debouncing.html"><strong aria-hidden="true">70.</strong> Q70: Debouncing</a></li><li class="chapter-item expanded affix "><li class="part-title">Quizzes & Challenges</li><li class="chapter-item expanded "><a href="quizzes/swift-quiz.html"><strong aria-hidden="true">71.</strong> Swift Quiz</a></li><li class="chapter-item expanded "><a href="quizzes/concurrency-quiz.html"><strong aria-hidden="true">72.</strong> Concurrency Quiz</a></li><li class="chapter-item expanded "><a href="quizzes/memory-quiz.html"><strong aria-hidden="true">73.</strong> Memory Quiz</a></li><li class="chapter-item expanded "><a href="quizzes/ui-quiz.html"><strong aria-hidden="true">74.</strong> UI Quiz</a></li><li class="chapter-item expanded "><a href="quizzes/networking-quiz.html"><strong aria-hidden="true">75.</strong> Networking Quiz</a></li><li class="chapter-item expanded "><a href="quizzes/final-challenge.html"><strong aria-hidden="true">76.</strong> Final Challenge</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">iOS Interview Mastery: 100 Questions to Win</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/durellwilson/ios-interview-mastery" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ios-interview-mastery-100-questions-to-win"><a class="header" href="#ios-interview-mastery-100-questions-to-win">iOS Interview Mastery: 100 Questions to Win</a></h1>
<blockquote>
<p>If you can answer these 100 questions, you don't walk into interviews with confidence‚Ä¶ <strong>you walk in prepared to win.</strong></p>
</blockquote>
<h2 id="-what-youll-master"><a class="header" href="#-what-youll-master">üéØ What You'll Master</a></h2>
<p>This course covers <strong>70 essential iOS interview questions</strong> across 5 critical domains:</p>
<ul>
<li><strong>Swift &amp; Language (Q1-20)</strong>: Core language concepts, protocols, generics, closures</li>
<li><strong>Concurrency (Q21-30)</strong>: GCD, async-await, actors, race conditions</li>
<li><strong>Memory Management (Q31-40)</strong>: ARC, retain cycles, memory leaks</li>
<li><strong>UIKit &amp; SwiftUI (Q41-60)</strong>: Lifecycles, layouts, state management</li>
<li><strong>Networking (Q61-70)</strong>: URLSession, JSON, caching, error handling</li>
</ul>
<h2 id="-learning-approach"><a class="header" href="#-learning-approach">üöÄ Learning Approach</a></h2>
<p>Each question includes:</p>
<p>‚úÖ <strong>Clear Explanation</strong> - Understand the concept deeply<br />
‚úÖ <strong>Code Examples</strong> - See it in action<br />
‚úÖ <strong>Common Pitfalls</strong> - Avoid interview mistakes<br />
‚úÖ <strong>Interview Tips</strong> - How to answer confidently<br />
‚úÖ <strong>Practice Challenge</strong> - Prove your mastery</p>
<h2 id="-quizzes--challenges"><a class="header" href="#-quizzes--challenges">üìä Quizzes &amp; Challenges</a></h2>
<p>Test your knowledge with:</p>
<ul>
<li>Section quizzes after each domain</li>
<li>Hands-on coding challenges</li>
<li>Real interview scenarios</li>
<li>Final mastery assessment</li>
</ul>
<h2 id="-who-this-is-for"><a class="header" href="#-who-this-is-for">üéì Who This Is For</a></h2>
<ul>
<li>iOS developers preparing for interviews</li>
<li>Engineers wanting to level up their Swift knowledge</li>
<li>Anyone seeking mastery of iOS fundamentals</li>
<li>Developers transitioning to iOS</li>
</ul>
<h2 id="-how-to-use-this-course"><a class="header" href="#-how-to-use-this-course">üí™ How to Use This Course</a></h2>
<ol>
<li><strong>Read each question thoroughly</strong></li>
<li><strong>Try to answer before reading the solution</strong></li>
<li><strong>Study the code examples</strong></li>
<li><strong>Complete the practice challenges</strong></li>
<li><strong>Take the quizzes to test retention</strong></li>
<li><strong>Repeat sections until you achieve mastery</strong></li>
</ol>
<h2 id="-success-metrics"><a class="header" href="#-success-metrics">üèÜ Success Metrics</a></h2>
<p>You'll know you've mastered this when you can:</p>
<ul>
<li>Explain each concept to a junior developer</li>
<li>Write code examples from memory</li>
<li>Identify issues in code snippets instantly</li>
<li>Answer follow-up questions with confidence</li>
</ul>
<hr />
<p><strong>Ready to dominate your next iOS interview?</strong></p>
<p>Let's begin with Swift &amp; Language fundamentals ‚Üí</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-flashcards---all-70-questions"><a class="header" href="#-flashcards---all-70-questions">üé¥ Flashcards - All 70 Questions</a></h1>
<p>Use these flashcards for quick review and memorization. Click to reveal answers.</p>
<h2 id="swift--language-1-20"><a class="header" href="#swift--language-1-20">Swift &amp; Language (1-20)</a></h2>
<details>
<summary><strong>Q1: What's the difference between struct and class?</strong></summary>
<p><strong>Answer</strong>: Structs are value types (copied), classes are reference types (shared). Classes support inheritance and deinitializers, structs don't.</p>
<p><strong>Key Point</strong>: <code>let</code> on struct = immutable. <code>let</code> on class = constant reference, mutable properties.</p>
</details>
<details>
<summary><strong>Q2: Value type vs reference type?</strong></summary>
<p><strong>Answer</strong>: Value types (struct, enum) are copied on assignment. Reference types (class) share the same instance.</p>
<p><strong>Memory</strong>: Value types on stack (usually), reference types on heap.</p>
</details>
<details>
<summary><strong>Q3: How does ARC work?</strong></summary>
<p><strong>Answer</strong>: Automatic Reference Counting tracks strong references. When count reaches 0, instance is deallocated. Works at compile-time.</p>
<p><strong>Formula</strong>: +1 on create, -1 on remove, 0 = dealloc</p>
</details>
<details>
<summary><strong>Q4: Strong, weak, unowned?</strong></summary>
<p><strong>Answer</strong>: </p>
<ul>
<li><strong>Strong</strong>: Default, increases reference count</li>
<li><strong>Weak</strong>: Optional, doesn't increase count, becomes nil when deallocated</li>
<li><strong>Unowned</strong>: Non-optional, doesn't increase count, crashes if accessed after dealloc</li>
</ul>
</details>
<details>
<summary><strong>Q5: What causes retain cycles?</strong></summary>
<p><strong>Answer</strong>: Two objects holding strong references to each other. Common in: closures capturing self, parent-child relationships, delegates.</p>
<p><strong>Fix</strong>: Use <code>weak</code> or <code>unowned</code> to break the cycle.</p>
</details>
<details>
<summary><strong>Q6: What are property wrappers?</strong></summary>
<p><strong>Answer</strong>: Reusable code that adds behavior to properties. Examples: <code>@State</code>, <code>@Published</code>, <code>@UserDefault</code>.</p>
<p><strong>Syntax</strong>: <code>@propertyWrapper struct Wrapper { var wrappedValue: T }</code></p>
</details>
<details>
<summary><strong>Q7: What is Codable?</strong></summary>
<p><strong>Answer</strong>: Protocol for encoding/decoding. Combines <code>Encodable</code> + <code>Decodable</code>. Auto-synthesized for simple types.</p>
<p><strong>Usage</strong>: <code>struct User: Codable { let name: String }</code></p>
</details>
<details>
<summary><strong>Q8: map, flatMap, compactMap?</strong></summary>
<p><strong>Answer</strong>:</p>
<ul>
<li><strong>map</strong>: Transform each element</li>
<li><strong>flatMap</strong>: Transform + flatten nested arrays</li>
<li><strong>compactMap</strong>: Transform + remove nils</li>
</ul>
</details>
<details>
<summary><strong>Q9: What are generics?</strong></summary>
<p><strong>Answer</strong>: Write flexible, reusable code that works with any type. Provides type safety without duplication.</p>
<p><strong>Example</strong>: <code>func swap&lt;T&gt;(_ a: inout T, _ b: inout T)</code></p>
</details>
<details>
<summary><strong>Q10: What is a protocol?</strong></summary>
<p><strong>Answer</strong>: Blueprint of methods, properties, and requirements. Defines &quot;what&quot; not &quot;how&quot;. Enables polymorphism.</p>
<p><strong>Key</strong>: Can be adopted by classes, structs, and enums.</p>
</details>
<details>
<summary><strong>Q11: Protocol vs class inheritance?</strong></summary>
<p><strong>Answer</strong>: </p>
<ul>
<li><strong>Protocol</strong>: Multiple adoption, no implementation (unless extension)</li>
<li><strong>Class</strong>: Single inheritance, provides implementation</li>
</ul>
</details>
<details>
<summary><strong>Q12: Associated types in protocols?</strong></summary>
<p><strong>Answer</strong>: Placeholder type in protocol, defined by conforming type. Like generics for protocols.</p>
<p><strong>Syntax</strong>: <code>associatedtype Item</code></p>
</details>
<details>
<summary><strong>Q13: What are extensions for?</strong></summary>
<p><strong>Answer</strong>: Add functionality to existing types without subclassing. Can add methods, computed properties, initializers, protocol conformance.</p>
<p><strong>Cannot</strong>: Add stored properties or override existing methods.</p>
</details>
<details>
<summary><strong>Q14: Static vs class methods?</strong></summary>
<p><strong>Answer</strong>:</p>
<ul>
<li><strong>static</strong>: Cannot be overridden</li>
<li><strong>class</strong>: Can be overridden in subclasses (classes only)</li>
</ul>
</details>
<details>
<summary><strong>Q15: What is a closure?</strong></summary>
<p><strong>Answer</strong>: Self-contained block of code that can be passed around. Can capture values from surrounding context.</p>
<p><strong>Types</strong>: Global functions, nested functions, closure expressions.</p>
</details>
<details>
<summary><strong>Q16: Escaping vs non-escaping?</strong></summary>
<p><strong>Answer</strong>:</p>
<ul>
<li><strong>Non-escaping</strong> (default): Executed before function returns</li>
<li><strong>Escaping</strong> (<code>@escaping</code>): Can outlive function, stored or called later</li>
</ul>
</details>
<details>
<summary><strong>Q17: What is @autoclosure?</strong></summary>
<p><strong>Answer</strong>: Automatically wraps expression in closure. Delays evaluation. Used for short-circuit evaluation.</p>
<p><strong>Example</strong>: <code>func assert(_ condition: @autoclosure () -&gt; Bool)</code></p>
</details>
<details>
<summary><strong>Q18: What is inout?</strong></summary>
<p><strong>Answer</strong>: Pass parameter by reference, allowing function to modify original value. Creates copy-in, copy-out behavior.</p>
<p><strong>Syntax</strong>: <code>func increment(_ value: inout Int)</code></p>
</details>
<details>
<summary><strong>Q19: What is optional chaining?</strong></summary>
<p><strong>Answer</strong>: Query optional properties/methods with <code>?</code>. Returns nil if any part is nil. Alternative to forced unwrapping.</p>
<p><strong>Example</strong>: <code>user?.address?.street</code></p>
</details>
<details>
<summary><strong>Q20: Computed vs stored properties?</strong></summary>
<p><strong>Answer</strong>:</p>
<ul>
<li><strong>Stored</strong>: Hold value in memory</li>
<li><strong>Computed</strong>: Calculate value on access, no storage</li>
</ul>
</details>
<h2 id="concurrency-21-30"><a class="header" href="#concurrency-21-30">Concurrency (21-30)</a></h2>
<details>
<summary><strong>Q21: What is GCD?</strong></summary>
<p><strong>Answer</strong>: Grand Central Dispatch - low-level API for managing concurrent operations. Uses queues to execute tasks.</p>
<p><strong>Key</strong>: Abstracts thread management.</p>
</details>
<details>
<summary><strong>Q22: Sync vs async?</strong></summary>
<p><strong>Answer</strong>:</p>
<ul>
<li><strong>Sync</strong>: Blocks until task completes</li>
<li><strong>Async</strong>: Returns immediately, task runs in background</li>
</ul>
</details>
<details>
<summary><strong>Q23: Serial vs concurrent queues?</strong></summary>
<p><strong>Answer</strong>:</p>
<ul>
<li><strong>Serial</strong>: One task at a time, in order</li>
<li><strong>Concurrent</strong>: Multiple tasks simultaneously</li>
</ul>
</details>
<details>
<summary><strong>Q24: What is a race condition?</strong></summary>
<p><strong>Answer</strong>: Multiple threads access shared data simultaneously, causing unpredictable results. Fixed with synchronization (locks, queues, actors).</p>
</details>
<details>
<summary><strong>Q25: What is a deadlock?</strong></summary>
<p><strong>Answer</strong>: Two or more threads waiting for each other, causing permanent block. Often from nested sync calls on same queue.</p>
</details>
<details>
<summary><strong>Q26: How does DispatchGroup work?</strong></summary>
<p><strong>Answer</strong>: Groups multiple tasks, notifies when all complete. Use <code>enter()</code>/<code>leave()</code> or pass to async calls.</p>
<p><strong>Usage</strong>: Coordinate multiple network calls.</p>
</details>
<details>
<summary><strong>Q27: What is OperationQueue?</strong></summary>
<p><strong>Answer</strong>: Higher-level abstraction over GCD. Supports dependencies, cancellation, priorities. Uses Operation objects.</p>
</details>
<details>
<summary><strong>Q28: How does async-await work?</strong></summary>
<p><strong>Answer</strong>: Modern concurrency syntax. <code>async</code> marks function as asynchronous, <code>await</code> suspends until result ready. Compiler handles continuations.</p>
</details>
<details>
<summary><strong>Q29: What are actors?</strong></summary>
<p><strong>Answer</strong>: Reference type that protects mutable state from data races. Only one task can access at a time. Automatic synchronization.</p>
</details>
<details>
<summary><strong>Q30: What does MainActor do?</strong></summary>
<p><strong>Answer</strong>: Global actor representing main thread. Ensures UI updates happen on main thread. Use <code>@MainActor</code> annotation.</p>
</details>
<h2 id="memory-management-31-40"><a class="header" href="#memory-management-31-40">Memory Management (31-40)</a></h2>
<details>
<summary><strong>Q31: How does ARC allocate/free memory?</strong></summary>
<p><strong>Answer</strong>: Allocates on heap when instance created. Tracks references. Frees when count = 0. Inserts retain/release at compile time.</p>
</details>
<details>
<summary><strong>Q32: What do weak references do?</strong></summary>
<p><strong>Answer</strong>: Don't increase reference count. Automatically become nil when object deallocated. Always optional. Prevent retain cycles.</p>
</details>
<details>
<summary><strong>Q33: What do unowned references do?</strong></summary>
<p><strong>Answer</strong>: Don't increase reference count. Non-optional. Assume object always exists. Crash if accessed after deallocation.</p>
<p><strong>Use when</strong>: Object lifetime guaranteed.</p>
</details>
<details>
<summary><strong>Q34: Strong reference cycles in closures?</strong></summary>
<p><strong>Answer</strong>: Closure captures self strongly, self holds closure strongly = cycle. Fix with capture list <code>[weak self]</code> or <code>[unowned self]</code>.</p>
</details>
<details>
<summary><strong>Q35: Capture list usage?</strong></summary>
<p><strong>Answer</strong>: Define how closure captures values. Syntax: <code>{ [weak self, unowned obj] in }</code>. Prevents retain cycles.</p>
</details>
<details>
<summary><strong>Q36: What causes memory leaks?</strong></summary>
<p><strong>Answer</strong>: Retain cycles, strong delegate references, closures capturing self, timers, observers not removed.</p>
</details>
<details>
<summary><strong>Q37: Detect leaks with Instruments?</strong></summary>
<p><strong>Answer</strong>: Use Leaks instrument. Shows leaked objects, allocation stack trace. Also use Memory Graph Debugger in Xcode.</p>
</details>
<details>
<summary><strong>Q38: MVVM retain cycle examples?</strong></summary>
<p><strong>Answer</strong>: ViewModel holds closure, closure captures ViewModel. View holds ViewModel, ViewModel holds View. Fix with weak references.</p>
</details>
<details>
<summary><strong>Q39: Memory warning handling?</strong></summary>
<p><strong>Answer</strong>: iOS sends warning when low memory. Override <code>didReceiveMemoryWarning()</code>. Clear caches, release non-essential resources.</p>
</details>
<details>
<summary><strong>Q40: Reference counting under the hood?</strong></summary>
<p><strong>Answer</strong>: Each object has reference count field. Retain increments, release decrements. When 0, dealloc called. Atomic operations for thread safety.</p>
</details>
<h2 id="uikit--swiftui-41-60"><a class="header" href="#uikit--swiftui-41-60">UIKit &amp; SwiftUI (41-60)</a></h2>
<details>
<summary><strong>Q41: UIViewController lifecycle?</strong></summary>
<p><strong>Answer</strong>: <code>init</code> ‚Üí <code>loadView</code> ‚Üí <code>viewDidLoad</code> ‚Üí <code>viewWillAppear</code> ‚Üí <code>viewDidAppear</code> ‚Üí <code>viewWillDisappear</code> ‚Üí <code>viewDidDisappear</code> ‚Üí <code>deinit</code></p>
</details>
<details>
<summary><strong>Q42: App lifecycle?</strong></summary>
<p><strong>Answer</strong>: Not Running ‚Üí Inactive ‚Üí Active ‚Üí Background ‚Üí Suspended. Use SceneDelegate (iOS 13+) or AppDelegate.</p>
</details>
<details>
<summary><strong>Q43: Frame vs bounds?</strong></summary>
<p><strong>Answer</strong>:</p>
<ul>
<li><strong>Frame</strong>: Position/size in superview's coordinate system</li>
<li><strong>Bounds</strong>: Position/size in own coordinate system (origin usually 0,0)</li>
</ul>
</details>
<details>
<summary><strong>Q44: Auto Layout basics?</strong></summary>
<p><strong>Answer</strong>: Constraint-based layout system. Define relationships between views. Adapts to different screen sizes. Uses constraints (equal, greater, less).</p>
</details>
<details>
<summary><strong>Q45: Constraints vs frames?</strong></summary>
<p><strong>Answer</strong>:</p>
<ul>
<li><strong>Constraints</strong>: Adaptive, relationship-based, works across devices</li>
<li><strong>Frames</strong>: Fixed positions, manual calculation, breaks on rotation</li>
</ul>
</details>
<details>
<summary><strong>Q46: Table view cell reuse?</strong></summary>
<p><strong>Answer</strong>: Cells dequeued from reuse pool instead of creating new. Improves performance. Must reset cell state in <code>prepareForReuse()</code>.</p>
</details>
<details>
<summary><strong>Q47: Diffable data source?</strong></summary>
<p><strong>Answer</strong>: Modern UITableView/UICollectionView data source. Uses snapshots. Automatic animations. Type-safe. No index path crashes.</p>
</details>
<details>
<summary><strong>Q48: Compositional layout?</strong></summary>
<p><strong>Answer</strong>: Flexible UICollectionView layout. Compose sections with different layouts. Supports groups, items, sections. Replaces flow layout.</p>
</details>
<details>
<summary><strong>Q49: SwiftUI view lifecycle?</strong></summary>
<p><strong>Answer</strong>: <code>init</code> ‚Üí <code>body</code> ‚Üí <code>onAppear</code> ‚Üí <code>onDisappear</code>. No viewDidLoad equivalent. Use <code>.task</code> for async work.</p>
</details>
<details>
<summary><strong>Q50: @State vs @Binding?</strong></summary>
<p><strong>Answer</strong>:</p>
<ul>
<li><strong>@State</strong>: Source of truth, owned by view</li>
<li><strong>@Binding</strong>: Two-way connection to @State, doesn't own data</li>
</ul>
</details>
<details>
<summary><strong>Q51: @ObservedObject vs @StateObject?</strong></summary>
<p><strong>Answer</strong>:</p>
<ul>
<li><strong>@StateObject</strong>: Creates and owns object, survives view updates</li>
<li><strong>@ObservedObject</strong>: Observes external object, can be recreated</li>
</ul>
</details>
<details>
<summary><strong>Q52: Environment values?</strong></summary>
<p><strong>Answer</strong>: Pass data down view hierarchy without explicit parameters. System values (colorScheme) or custom. Use <code>@Environment</code>.</p>
</details>
<details>
<summary><strong>Q53: NavigationStack basics?</strong></summary>
<p><strong>Answer</strong>: Modern navigation (iOS 16+). Programmatic navigation with path. Type-safe. Replaces NavigationView + NavigationLink.</p>
</details>
<details>
<summary><strong>Q54: SwiftUI diff engine?</strong></summary>
<p><strong>Answer</strong>: Compares old and new view trees. Only updates changed views. Uses view identity and type. Efficient rendering.</p>
</details>
<details>
<summary><strong>Q55: View identity in SwiftUI?</strong></summary>
<p><strong>Answer</strong>: How SwiftUI tracks views across updates. Based on type, position, and explicit <code>id()</code>. Affects state preservation and animations.</p>
</details>
<details>
<summary><strong>Q56: LazyVStack and LazyHStack?</strong></summary>
<p><strong>Answer</strong>: Load views on-demand as they appear. Better performance for long lists. Unlike VStack/HStack which load all immediately.</p>
</details>
<details>
<summary><strong>Q57: Scroll performance best practices?</strong></summary>
<p><strong>Answer</strong>: Use lazy stacks, avoid heavy computations in body, cache images, use <code>.drawingGroup()</code> for complex views, minimize state changes.</p>
</details>
<details>
<summary><strong>Q58: Rendering pipeline in SwiftUI?</strong></summary>
<p><strong>Answer</strong>: State change ‚Üí body called ‚Üí diff ‚Üí update ‚Üí render. Three phases: update, layout, render. Optimized by SwiftUI.</p>
</details>
<details>
<summary><strong>Q59: UIKit vs SwiftUI architecture?</strong></summary>
<p><strong>Answer</strong>:</p>
<ul>
<li><strong>UIKit</strong>: Imperative, mutable, view controllers, delegates</li>
<li><strong>SwiftUI</strong>: Declarative, immutable, views, data flow</li>
</ul>
</details>
<details>
<summary><strong>Q60: When to mix SwiftUI + UIKit?</strong></summary>
<p><strong>Answer</strong>: Use UIViewRepresentable/UIViewControllerRepresentable. When: UIKit component not in SwiftUI, legacy code, specific UIKit features needed.</p>
</details>
<h2 id="networking-61-70"><a class="header" href="#networking-61-70">Networking (61-70)</a></h2>
<details>
<summary><strong>Q61: URLSession flow?</strong></summary>
<p><strong>Answer</strong>: Create URLRequest ‚Üí Create URLSession ‚Üí Create task (data/download/upload) ‚Üí Resume task ‚Üí Handle response/data ‚Üí Parse.</p>
</details>
<details>
<summary><strong>Q62: DataTask vs DownloadTask?</strong></summary>
<p><strong>Answer</strong>:</p>
<ul>
<li><strong>DataTask</strong>: Returns data in memory, for small responses</li>
<li><strong>DownloadTask</strong>: Saves to file, for large files, supports background</li>
</ul>
</details>
<details>
<summary><strong>Q63: Decoding JSON with Codable?</strong></summary>
<p><strong>Answer</strong>: <code>JSONDecoder().decode(Type.self, from: data)</code>. Struct must conform to Codable. Use CodingKeys for custom mapping.</p>
</details>
<details>
<summary><strong>Q64: Handling errors in networking?</strong></summary>
<p><strong>Answer</strong>: Check URLError, HTTP status codes, decoding errors. Use Result type. Provide user-friendly messages. Implement retry logic.</p>
</details>
<details>
<summary><strong>Q65: What is HTTP caching?</strong></summary>
<p><strong>Answer</strong>: Store responses to avoid repeated requests. URLCache handles automatically. Control with Cache-Control headers. Improves performance.</p>
</details>
<details>
<summary><strong>Q66: What are URLRequests?</strong></summary>
<p><strong>Answer</strong>: Encapsulates request details: URL, method (GET/POST), headers, body, timeout. Immutable. Use URLComponents for URL building.</p>
</details>
<details>
<summary><strong>Q67: REST vs GraphQL?</strong></summary>
<p><strong>Answer</strong>:</p>
<ul>
<li><strong>REST</strong>: Multiple endpoints, over/under-fetching, simple</li>
<li><strong>GraphQL</strong>: Single endpoint, request exact data, complex</li>
</ul>
</details>
<details>
<summary><strong>Q68: Handling status codes?</strong></summary>
<p><strong>Answer</strong>: 2xx = success, 3xx = redirect, 4xx = client error, 5xx = server error. Check <code>httpResponse.statusCode</code>. Handle each appropriately.</p>
</details>
<details>
<summary><strong>Q69: Retry mechanism?</strong></summary>
<p><strong>Answer</strong>: Exponential backoff, max retry count, only retry on specific errors (network, 5xx). Use DispatchQueue.asyncAfter or Task.sleep.</p>
</details>
<details>
<summary><strong>Q70: Debouncing network calls?</strong></summary>
<p><strong>Answer</strong>: Delay execution until user stops typing. Cancel previous requests. Use Timer, Combine's debounce, or Task cancellation.</p>
</details>
<hr />
<h2 id="-study-tips"><a class="header" href="#-study-tips">üìö Study Tips</a></h2>
<ol>
<li><strong>Review daily</strong>: Go through 10 flashcards per day</li>
<li><strong>Active recall</strong>: Try to answer before revealing</li>
<li><strong>Spaced repetition</strong>: Review difficult cards more often</li>
<li><strong>Practice coding</strong>: Don't just memorize, write code</li>
<li><strong>Teach others</strong>: Best way to solidify understanding</li>
</ol>
<hr />
<p><a href="./introduction.html">‚Üê Back to Course</a> | <a href="./quizzes/swift-quiz.html">Take Quizzes ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q1-whats-the-difference-between-struct-and-class"><a class="header" href="#q1-whats-the-difference-between-struct-and-class">Q1: What's the difference between struct and class?</a></h1>
<h2 id="-the-answer"><a class="header" href="#-the-answer">üéØ The Answer</a></h2>
<p><strong>Structs</strong> are <strong>value types</strong> - they're copied when assigned or passed.<br />
<strong>Classes</strong> are <strong>reference types</strong> - they're shared via references.</p>
<h2 id="-deep-dive"><a class="header" href="#-deep-dive">üìñ Deep Dive</a></h2>
<h3 id="key-differences"><a class="header" href="#key-differences">Key Differences</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Struct</th><th>Class</th></tr></thead><tbody>
<tr><td>Type</td><td>Value type</td><td>Reference type</td></tr>
<tr><td>Inheritance</td><td>‚ùå No</td><td>‚úÖ Yes</td></tr>
<tr><td>Deinitializers</td><td>‚ùå No</td><td>‚úÖ Yes</td></tr>
<tr><td>Reference counting</td><td>‚ùå No</td><td>‚úÖ Yes (ARC)</td></tr>
<tr><td>Mutability</td><td>Explicit <code>mutating</code></td><td>Implicit</td></tr>
<tr><td>Thread safety</td><td>Safer (copied)</td><td>Requires care</td></tr>
</tbody></table>
</div>
<h3 id="code-example"><a class="header" href="#code-example">Code Example</a></h3>
<pre><code class="language-swift">// STRUCT - Value Type
struct Point {
    var x: Int
    var y: Int
}

var point1 = Point(x: 10, y: 20)
var point2 = point1  // COPY created
point2.x = 30

print(point1.x)  // 10 (unchanged)
print(point2.x)  // 30 (changed)

// CLASS - Reference Type
class Person {
    var name: String
    init(name: String) { self.name = name }
}

var person1 = Person(name: &quot;Alice&quot;)
var person2 = person1  // REFERENCE shared
person2.name = &quot;Bob&quot;

print(person1.name)  // &quot;Bob&quot; (changed!)
print(person2.name)  // &quot;Bob&quot; (same reference)
</code></pre>
<h2 id="-common-pitfalls"><a class="header" href="#-common-pitfalls">‚ö†Ô∏è Common Pitfalls</a></h2>
<h3 id="pitfall-1-unexpected-mutations"><a class="header" href="#pitfall-1-unexpected-mutations">Pitfall 1: Unexpected Mutations</a></h3>
<pre><code class="language-swift">class Counter {
    var count = 0
}

let counter = Counter()
counter.count = 10  // ‚úÖ Works! 'let' only makes reference constant
</code></pre>
<h3 id="pitfall-2-struct-mutation"><a class="header" href="#pitfall-2-struct-mutation">Pitfall 2: Struct Mutation</a></h3>
<pre><code class="language-swift">struct Counter {
    var count = 0
    
    mutating func increment() {  // Must be 'mutating'
        count += 1
    }
}

let counter = Counter()
// counter.increment()  // ‚ùå Error: 'let' prevents mutation
</code></pre>
<h2 id="-when-to-use-each"><a class="header" href="#-when-to-use-each">üí° When to Use Each</a></h2>
<h3 id="use-struct-when"><a class="header" href="#use-struct-when">Use Struct When:</a></h3>
<ul>
<li>Modeling simple data (Point, Size, Color)</li>
<li>You want value semantics</li>
<li>Thread safety is important</li>
<li>No inheritance needed</li>
</ul>
<h3 id="use-class-when"><a class="header" href="#use-class-when">Use Class When:</a></h3>
<ul>
<li>Need inheritance</li>
<li>Need deinitializers</li>
<li>Modeling identity (User, Session)</li>
<li>Working with Objective-C APIs</li>
</ul>
<h2 id="-interview-tips"><a class="header" href="#-interview-tips">üé§ Interview Tips</a></h2>
<p><strong>Interviewer</strong>: &quot;Why does Swift prefer structs?&quot;</p>
<p><strong>You</strong>: &quot;Swift prefers structs because they're safer by default - no retain cycles, better thread safety, and clearer ownership. The compiler can optimize them better too. But classes are essential when you need inheritance or reference semantics.&quot;</p>
<p><strong>Follow-up</strong>: &quot;Can structs have methods?&quot;</p>
<p><strong>You</strong>: &quot;Yes! Structs can have methods, computed properties, initializers, and even conform to protocols. They just can't inherit from other structs.&quot;</p>
<h2 id="-practice-challenge"><a class="header" href="#-practice-challenge">üèãÔ∏è Practice Challenge</a></h2>
<p>Create a <code>BankAccount</code> struct and a <code>User</code> class. The User should have a reference to their account. Demonstrate:</p>
<ol>
<li>Copying a BankAccount creates a new account</li>
<li>Multiple Users can't share the same account reference</li>
<li>Implement a <code>transfer</code> method that's safe</li>
</ol>
<details>
<summary>Solution</summary>
<pre><code class="language-swift">struct BankAccount {
    var balance: Double
    let accountNumber: String
    
    mutating func deposit(_ amount: Double) {
        balance += amount
    }
    
    mutating func withdraw(_ amount: Double) -&gt; Bool {
        guard balance &gt;= amount else { return false }
        balance -= amount
        return true
    }
}

class User {
    let name: String
    var account: BankAccount
    
    init(name: String, account: BankAccount) {
        self.name = name
        self.account = account
    }
    
    func transfer(to recipient: User, amount: Double) -&gt; Bool {
        guard account.withdraw(amount) else { return false }
        recipient.account.deposit(amount)
        return true
    }
}

// Test
var account1 = BankAccount(balance: 1000, accountNumber: &quot;001&quot;)
var account2 = BankAccount(balance: 500, accountNumber: &quot;002&quot;)

let alice = User(name: &quot;Alice&quot;, account: account1)
let bob = User(name: &quot;Bob&quot;, account: account2)

alice.transfer(to: bob, amount: 200)
print(alice.account.balance)  // 800
print(bob.account.balance)    // 700
</code></pre>
</details>
<h2 id="-mastery-checklist"><a class="header" href="#-mastery-checklist">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Can explain value vs reference types</li>
<li><input disabled="" type="checkbox"/>
Know when to use struct vs class</li>
<li><input disabled="" type="checkbox"/>
Understand mutating keyword</li>
<li><input disabled="" type="checkbox"/>
Can identify copy vs reference behavior</li>
<li><input disabled="" type="checkbox"/>
Know the performance implications</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="swift/./02-value-vs-reference.html">Q2: Value vs Reference Types ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q2-value-type-vs-reference-type"><a class="header" href="#q2-value-type-vs-reference-type">Q2: Value Type vs Reference Type</a></h1>
<h2 id="-the-one-sentence-answer"><a class="header" href="#-the-one-sentence-answer">üéØ The One-Sentence Answer</a></h2>
<p><strong>Value types are copied when assigned or passed; reference types share the same instance.</strong></p>
<h2 id="-complete-explanation"><a class="header" href="#-complete-explanation">üìñ Complete Explanation</a></h2>
<h3 id="the-core-difference"><a class="header" href="#the-core-difference">The Core Difference</a></h3>
<pre><code class="language-swift">// VALUE TYPE - Each variable gets its own copy
var a = 5
var b = a
b = 10
print(a)  // 5 (unchanged)
print(b)  // 10 (changed)

// REFERENCE TYPE - Variables share the same instance
class Box { var value: Int; init(_ v: Int) { value = v } }
var x = Box(5)
var y = x
y.value = 10
print(x.value)  // 10 (changed!)
print(y.value)  // 10 (same instance)
</code></pre>
<h3 id="memory-behavior"><a class="header" href="#memory-behavior">Memory Behavior</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Value Type</th><th>Reference Type</th></tr></thead><tbody>
<tr><td>Storage</td><td>Stack (usually)</td><td>Heap</td></tr>
<tr><td>Assignment</td><td>Copy</td><td>Reference</td></tr>
<tr><td>Mutation</td><td>Requires <code>var</code></td><td>Can mutate with <code>let</code></td></tr>
<tr><td>Thread Safety</td><td>Safer</td><td>Requires synchronization</td></tr>
<tr><td>Performance</td><td>Faster for small data</td><td>Better for large data</td></tr>
</tbody></table>
</div>
<h3 id="swift-types"><a class="header" href="#swift-types">Swift Types</a></h3>
<p><strong>Value Types:</strong></p>
<ul>
<li><code>struct</code></li>
<li><code>enum</code></li>
<li><code>Int</code>, <code>Double</code>, <code>String</code>, <code>Array</code>, <code>Dictionary</code>, <code>Set</code></li>
<li>Tuples</li>
</ul>
<p><strong>Reference Types:</strong></p>
<ul>
<li><code>class</code></li>
<li><code>function</code> (closures)</li>
<li>Actors</li>
</ul>
<h2 id="-visual-mental-model"><a class="header" href="#-visual-mental-model">üí° Visual Mental Model</a></h2>
<pre><code>VALUE TYPE (Copy)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  5  ‚îÇ  ‚Üí   ‚îÇ  5  ‚îÇ  (Independent copies)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  var a       var b

REFERENCE TYPE (Share)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      
‚îÇ Box ‚îÇ  ‚Üê‚îÄ‚îÄ‚îÄ var x
‚îÇ  5  ‚îÇ  ‚Üê‚îÄ‚îÄ‚îÄ var y  (Both point to same box)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      
</code></pre>
<h2 id="-deep-dive-why-this-matters"><a class="header" href="#-deep-dive-why-this-matters">üîç Deep Dive: Why This Matters</a></h2>
<h3 id="1-unexpected-mutations"><a class="header" href="#1-unexpected-mutations">1. Unexpected Mutations</a></h3>
<pre><code class="language-swift">// Value type - Safe
var numbers1 = [1, 2, 3]
var numbers2 = numbers1
numbers2.append(4)
print(numbers1)  // [1, 2, 3] ‚úÖ Safe

// Reference type - Surprising!
class NumberList {
    var items = [1, 2, 3]
}
var list1 = NumberList()
var list2 = list1
list2.items.append(4)
print(list1.items)  // [1, 2, 3, 4] ‚ö†Ô∏è Changed!
</code></pre>
<h3 id="2-function-parameters"><a class="header" href="#2-function-parameters">2. Function Parameters</a></h3>
<pre><code class="language-swift">func modify(_ value: Int) {
    var value = value
    value += 10
    // Original unchanged
}

func modify(_ object: Box) {
    object.value += 10
    // Original IS changed!
}
</code></pre>
<h3 id="3-collections"><a class="header" href="#3-collections">3. Collections</a></h3>
<pre><code class="language-swift">// Array is value type, but contains reference types
class Person { var name: String; init(_ n: String) { name = n } }

var people1 = [Person(&quot;Alice&quot;)]
var people2 = people1  // Array copied
people2[0].name = &quot;Bob&quot;  // But Person is reference!

print(people1[0].name)  // &quot;Bob&quot; - Person shared!
</code></pre>
<h2 id="-common-pitfalls-1"><a class="header" href="#-common-pitfalls-1">‚ö†Ô∏è Common Pitfalls</a></h2>
<h3 id="pitfall-1-assuming-let-makes-everything-immutable"><a class="header" href="#pitfall-1-assuming-let-makes-everything-immutable">Pitfall 1: Assuming <code>let</code> Makes Everything Immutable</a></h3>
<pre><code class="language-swift">class Counter {
    var count = 0
}

let counter = Counter()
counter.count = 10  // ‚úÖ Works! `let` only makes reference constant
</code></pre>
<h3 id="pitfall-2-copying-arrays-of-classes"><a class="header" href="#pitfall-2-copying-arrays-of-classes">Pitfall 2: Copying Arrays of Classes</a></h3>
<pre><code class="language-swift">class Item { var value = 0 }
var array1 = [Item()]
var array2 = array1  // Array copied, but Items shared!
array2[0].value = 10
print(array1[0].value)  // 10 (shared!)
</code></pre>
<h3 id="pitfall-3-dictionary-keys"><a class="header" href="#pitfall-3-dictionary-keys">Pitfall 3: Dictionary Keys</a></h3>
<pre><code class="language-swift">class BadKey: Hashable {
    var id: Int
    init(_ id: Int) { self.id = id }
    func hash(into hasher: inout Hasher) { hasher.combine(id) }
    static func == (lhs: BadKey, rhs: BadKey) -&gt; Bool { lhs.id == rhs.id }
}

var dict = [BadKey(1): &quot;value&quot;]
let key = BadKey(1)
dict[key] = &quot;new&quot;
key.id = 2  // ‚ö†Ô∏è Mutated key! Dictionary broken!
</code></pre>
<h2 id="-interview-answer-template"><a class="header" href="#-interview-answer-template">üé§ Interview Answer Template</a></h2>
<p><strong>Question</strong>: &quot;What's the difference between value and reference types?&quot;</p>
<p><strong>Your Answer</strong>:</p>
<blockquote>
<p>&quot;Value types like structs are copied when assigned or passed to functions, so each variable has its own independent copy. Reference types like classes share the same instance, so multiple variables can point to the same object.</p>
<p>This affects memory management - value types are typically stored on the stack and don't need ARC, while reference types are on the heap and use reference counting. It also impacts thread safety - value types are inherently safer because each thread gets its own copy.</p>
<p>In Swift, structs, enums, and basic types are value types, while classes and closures are reference types.&quot;</p>
</blockquote>
<p><strong>Follow-up</strong>: &quot;When would you choose one over the other?&quot;</p>
<p><strong>Your Answer</strong>:</p>
<blockquote>
<p>&quot;I use structs for simple data models where I want value semantics - like Point, Size, or User data. They're safer by default and prevent accidental mutations.</p>
<p>I use classes when I need inheritance, when modeling identity (like a User session), or when I need reference semantics - like a view controller or a shared cache. Classes are also necessary for Objective-C interop.&quot;</p>
</blockquote>
<h2 id="-practice-challenges"><a class="header" href="#-practice-challenges">üèãÔ∏è Practice Challenges</a></h2>
<h3 id="challenge-1-predict-the-output"><a class="header" href="#challenge-1-predict-the-output">Challenge 1: Predict the Output</a></h3>
<pre><code class="language-swift">struct Point {
    var x: Int
    var y: Int
}

class Circle {
    var center: Point
    var radius: Int
    init(center: Point, radius: Int) {
        self.center = center
        self.radius = radius
    }
}

var point = Point(x: 0, y: 0)
var circle1 = Circle(center: point, radius: 5)
var circle2 = circle1

circle2.center.x = 10
circle2.radius = 20

print(circle1.center.x)  // ?
print(circle1.radius)    // ?
print(point.x)           // ?
</code></pre>
<details>
<summary>Solution</summary>
<pre><code>circle1.center.x = 10  (Circle shared, Point copied into Circle)
circle1.radius = 20    (Circle shared)
point.x = 0            (Original Point unchanged)
</code></pre>
<p><strong>Explanation</strong>: <code>circle2</code> shares the same Circle instance as <code>circle1</code>, so changes affect both. But when Point was assigned to Circle, it was copied, so the original <code>point</code> is unchanged.</p>
</details>
<h3 id="challenge-2-fix-the-bug"><a class="header" href="#challenge-2-fix-the-bug">Challenge 2: Fix the Bug</a></h3>
<pre><code class="language-swift">class ViewModel {
    var items: [String] = []
    
    func getItems() -&gt; [String] {
        return items
    }
}

let vm = ViewModel()
vm.items = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]

var myItems = vm.getItems()
myItems.append(&quot;D&quot;)

// Bug: We don't want to modify vm.items, but...?
</code></pre>
<details>
<summary>Solution</summary>
<p><strong>No bug!</strong> Array is a value type, so <code>myItems</code> is a copy. <code>vm.items</code> is unchanged.</p>
<p>If items were a class:</p>
<pre><code class="language-swift">class ItemList {
    var items: [String] = []
}

class ViewModel {
    var itemList = ItemList()
    
    func getItems() -&gt; ItemList {
        return itemList  // ‚ö†Ô∏è Shared reference!
    }
}
</code></pre>
<p>Then you'd need to return a copy or use a struct.</p>
</details>
<h3 id="challenge-3-implement-copy-on-write"><a class="header" href="#challenge-3-implement-copy-on-write">Challenge 3: Implement Copy-on-Write</a></h3>
<p>Create a <code>Buffer</code> class that behaves like a value type using copy-on-write.</p>
<details>
<summary>Solution</summary>
<pre><code class="language-swift">final class Storage {
    var data: [Int]
    init(_ data: [Int]) { self.data = data }
}

struct Buffer {
    private var storage: Storage
    
    init(_ data: [Int]) {
        storage = Storage(data)
    }
    
    var data: [Int] {
        get { storage.data }
        set {
            if !isKnownUniquelyReferenced(&amp;storage) {
                storage = Storage(newValue)  // Copy on write
            } else {
                storage.data = newValue
            }
        }
    }
}

// Test
var buffer1 = Buffer([1, 2, 3])
var buffer2 = buffer1  // Shares storage
buffer2.data.append(4)  // Triggers copy
// buffer1 unchanged, buffer2 has copy
</code></pre>
</details>
<h2 id="-memory-tricks"><a class="header" href="#-memory-tricks">üß† Memory Tricks</a></h2>
<p><strong>Remember</strong>: &quot;<strong>V</strong>alue types <strong>V</strong>ary independently, <strong>R</strong>eference types <strong>R</strong>emain connected&quot;</p>
<p><strong>Mnemonic</strong>: </p>
<ul>
<li><strong>S</strong>tructs are <strong>S</strong>eparate (value)</li>
<li><strong>C</strong>lasses are <strong>C</strong>onnected (reference)</li>
</ul>
<h2 id="-mastery-checklist-1"><a class="header" href="#-mastery-checklist-1">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Can explain the difference in one sentence</li>
<li><input disabled="" type="checkbox"/>
Know which Swift types are value vs reference</li>
<li><input disabled="" type="checkbox"/>
Understand memory implications (stack vs heap)</li>
<li><input disabled="" type="checkbox"/>
Can predict behavior in code examples</li>
<li><input disabled="" type="checkbox"/>
Know when to use each type</li>
<li><input disabled="" type="checkbox"/>
Understand copy-on-write optimization</li>
<li><input disabled="" type="checkbox"/>
Can identify bugs related to type semantics</li>
</ul>
<h2 id="-quick-self-test"><a class="header" href="#-quick-self-test">üéØ Quick Self-Test</a></h2>
<ol>
<li>Is <code>String</code> a value or reference type? <strong>Value</strong></li>
<li>What happens when you assign a struct? <strong>Copy created</strong></li>
<li>Can you mutate a class property with <code>let</code>? <strong>Yes</strong></li>
<li>Are closures value or reference types? <strong>Reference</strong></li>
<li>What's stored on the heap? <strong>Reference types</strong></li>
</ol>
<p><strong>Score</strong>: 5/5 = Ready | 3-4/5 = Review | &lt;3/5 = Study more</p>
<hr />
<p><strong>Next</strong>: <a href="swift/./03-arc-basics.html">Q3: How ARC Works ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q3-how-arc-works"><a class="header" href="#q3-how-arc-works">Q3: How ARC Works</a></h1>
<h2 id="-the-answer-1"><a class="header" href="#-the-answer-1">üéØ The Answer</a></h2>
<p><strong>ARC (Automatic Reference Counting)</strong> automatically manages memory by tracking how many strong references point to each class instance. When the count reaches zero, the instance is deallocated.</p>
<h2 id="-deep-dive-1"><a class="header" href="#-deep-dive-1">üìñ Deep Dive</a></h2>
<h3 id="the-three-rules-of-arc"><a class="header" href="#the-three-rules-of-arc">The Three Rules of ARC</a></h3>
<ol>
<li><strong>Strong reference created</strong> ‚Üí Reference count +1</li>
<li><strong>Strong reference removed</strong> ‚Üí Reference count -1</li>
<li><strong>Count reaches 0</strong> ‚Üí Instance deallocated</li>
</ol>
<h3 id="code-example-1"><a class="header" href="#code-example-1">Code Example</a></h3>
<pre><code class="language-swift">class Person {
    let name: String
    
    init(name: String) {
        self.name = name
        print(&quot;\(name) is initialized&quot;)
    }
    
    deinit {
        print(&quot;\(name) is deallocated&quot;)
    }
}

// Reference count: 0
var person1: Person? = Person(name: &quot;Alice&quot;)  // RC: 1
var person2 = person1                          // RC: 2
var person3 = person1                          // RC: 3

person1 = nil  // RC: 2
person2 = nil  // RC: 1
person3 = nil  // RC: 0 ‚Üí deinit called!
</code></pre>
<h3 id="output"><a class="header" href="#output">Output:</a></h3>
<pre><code>Alice is initialized
Alice is deallocated
</code></pre>
<h2 id="-how-it-works-under-the-hood"><a class="header" href="#-how-it-works-under-the-hood">üîç How It Works Under the Hood</a></h2>
<pre><code class="language-swift">class Node {
    var value: Int
    var next: Node?
    
    init(value: Int) {
        self.value = value
    }
    
    deinit {
        print(&quot;Node \(value) deallocated&quot;)
    }
}

var head: Node? = Node(value: 1)  // RC: 1
head?.next = Node(value: 2)        // RC: 1 for node 2
head?.next?.next = Node(value: 3)  // RC: 1 for node 3

head = nil  // All nodes deallocated in order
</code></pre>
<h2 id="-common-pitfalls-2"><a class="header" href="#-common-pitfalls-2">‚ö†Ô∏è Common Pitfalls</a></h2>
<h3 id="pitfall-1-retain-cycles"><a class="header" href="#pitfall-1-retain-cycles">Pitfall 1: Retain Cycles</a></h3>
<pre><code class="language-swift">class Parent {
    var child: Child?
    deinit { print(&quot;Parent deallocated&quot;) }
}

class Child {
    var parent: Parent?  // ‚ö†Ô∏è Strong reference!
    deinit { print(&quot;Child deallocated&quot;) }
}

var parent: Parent? = Parent()
var child: Child? = Child()
parent?.child = child
child?.parent = parent

parent = nil
child = nil
// ‚ùå Nothing deallocated! Retain cycle!
</code></pre>
<h3 id="pitfall-2-closures-capturing-self"><a class="header" href="#pitfall-2-closures-capturing-self">Pitfall 2: Closures Capturing Self</a></h3>
<pre><code class="language-swift">class ViewController {
    var name = &quot;VC&quot;
    
    func setupHandler() {
        someAsyncCall {
            print(self.name)  // ‚ö†Ô∏è Strong capture!
        }
    }
    
    deinit { print(&quot;VC deallocated&quot;) }
}
</code></pre>
<h2 id="-arc-vs-garbage-collection"><a class="header" href="#-arc-vs-garbage-collection">üí° ARC vs Garbage Collection</a></h2>
<div class="table-wrapper"><table><thead><tr><th>ARC</th><th>Garbage Collection</th></tr></thead><tbody>
<tr><td>Compile-time</td><td>Runtime</td></tr>
<tr><td>Deterministic</td><td>Non-deterministic</td></tr>
<tr><td>No pause</td><td>Can pause app</td></tr>
<tr><td>Manual cycle breaking</td><td>Automatic</td></tr>
<tr><td>iOS/Swift</td><td>Java/C#</td></tr>
</tbody></table>
</div>
<h2 id="-interview-tips-1"><a class="header" href="#-interview-tips-1">üé§ Interview Tips</a></h2>
<p><strong>Interviewer</strong>: &quot;How does ARC differ from manual memory management?&quot;</p>
<p><strong>You</strong>: &quot;ARC automatically inserts retain and release calls at compile time, so we don't have to manually manage memory like in C. But we still need to understand ownership to avoid retain cycles.&quot;</p>
<p><strong>Follow-up</strong>: &quot;When does ARC not work?&quot;</p>
<p><strong>You</strong>: &quot;ARC only works with reference types (classes). Value types like structs don't need it. Also, ARC can't automatically break retain cycles - we need weak or unowned references for that.&quot;</p>
<h2 id="-practice-challenge-1"><a class="header" href="#-practice-challenge-1">üèãÔ∏è Practice Challenge</a></h2>
<p>Create a <code>Task</code> and <code>TaskManager</code> system where:</p>
<ol>
<li>TaskManager holds an array of tasks</li>
<li>Each Task has a completion handler</li>
<li>Prove that tasks are properly deallocated</li>
<li>Show what happens with a retain cycle</li>
</ol>
<details>
<summary>Solution</summary>
<pre><code class="language-swift">class Task {
    let id: Int
    var onComplete: (() -&gt; Void)?
    
    init(id: Int) {
        self.id = id
        print(&quot;Task \(id) created&quot;)
    }
    
    func execute() {
        print(&quot;Task \(id) executing&quot;)
        onComplete?()
    }
    
    deinit {
        print(&quot;Task \(id) deallocated&quot;)
    }
}

class TaskManager {
    var tasks: [Task] = []
    
    func addTask(_ task: Task) {
        tasks.append(task)
        
        // ‚úÖ Correct: weak self
        task.onComplete = { [weak self] in
            self?.removeTask(task)
        }
        
        // ‚ùå Wrong: creates retain cycle
        // task.onComplete = {
        //     self.removeTask(task)
        // }
    }
    
    func removeTask(_ task: Task) {
        tasks.removeAll { $0 === task }
        print(&quot;Task removed from manager&quot;)
    }
    
    deinit {
        print(&quot;TaskManager deallocated&quot;)
    }
}

// Test
var manager: TaskManager? = TaskManager()
let task = Task(id: 1)
manager?.addTask(task)
task.execute()
manager = nil  // Should deallocate everything
</code></pre>
</details>
<h2 id="-mastery-checklist-2"><a class="header" href="#-mastery-checklist-2">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Understand reference counting</li>
<li><input disabled="" type="checkbox"/>
Know when objects are deallocated</li>
<li><input disabled="" type="checkbox"/>
Can identify retain cycles</li>
<li><input disabled="" type="checkbox"/>
Understand ARC vs GC differences</li>
<li><input disabled="" type="checkbox"/>
Know ARC limitations</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="swift/./04-reference-types.html">Q4: Strong, Weak, Unowned ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q4-strong-weak-unowned"><a class="header" href="#q4-strong-weak-unowned">Q4: Strong, Weak, Unowned</a></h1>
<h2 id="-the-answer-2"><a class="header" href="#-the-answer-2">üéØ The Answer</a></h2>
<ul>
<li><strong>Strong</strong> (default): Increases reference count, keeps object alive</li>
<li><strong>Weak</strong>: Optional, doesn't increase count, becomes <code>nil</code> when object deallocated</li>
<li><strong>Unowned</strong>: Non-optional, doesn't increase count, crashes if accessed after deallocation</li>
</ul>
<h2 id="-deep-dive-2"><a class="header" href="#-deep-dive-2">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">class Person {
    let name: String
    var apartment: Apartment?
    
    init(name: String) {
        self.name = name
        print(&quot;\(name) is initialized&quot;)
    }
    
    deinit {
        print(&quot;\(name) is deallocated&quot;)
    }
}

class Apartment {
    let unit: String
    weak var tenant: Person?  // ‚úÖ weak prevents retain cycle
    
    init(unit: String) {
        self.unit = unit
    }
    
    deinit {
        print(&quot;Apartment \(unit) is deallocated&quot;)
    }
}

// Usage
var john: Person? = Person(name: &quot;John&quot;)
var unit4A: Apartment? = Apartment(unit: &quot;4A&quot;)

john?.apartment = unit4A
unit4A?.tenant = john

john = nil  // Both deallocated because weak broke the cycle
unit4A = nil
</code></pre>
<h3 id="when-to-use-each"><a class="header" href="#when-to-use-each">When to Use Each</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Use When</th><th>Example</th></tr></thead><tbody>
<tr><td><strong>Strong</strong></td><td>Default ownership</td><td>Properties, variables</td></tr>
<tr><td><strong>Weak</strong></td><td>Optional relationship, might be nil</td><td>Delegates, parent references</td></tr>
<tr><td><strong>Unowned</strong></td><td>Non-optional, guaranteed to exist</td><td>Child to parent (parent owns child)</td></tr>
</tbody></table>
</div>
<h3 id="unowned-example"><a class="header" href="#unowned-example">Unowned Example</a></h3>
<pre><code class="language-swift">class Customer {
    let name: String
    var card: CreditCard?
    
    init(name: String) {
        self.name = name
    }
    
    deinit { print(&quot;\(name) is deallocated&quot;) }
}

class CreditCard {
    let number: UInt64
    unowned let customer: Customer  // ‚úÖ Card can't exist without customer
    
    init(number: UInt64, customer: Customer) {
        self.number = number
        self.customer = customer
    }
    
    deinit { print(&quot;Card #\(number) is deallocated&quot;) }
}

var john: Customer? = Customer(name: &quot;John&quot;)
john?.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)
john = nil  // Both deallocated
</code></pre>
<h2 id="-common-pitfalls-3"><a class="header" href="#-common-pitfalls-3">‚ö†Ô∏è Common Pitfalls</a></h2>
<h3 id="pitfall-1-using-unowned-when-object-might-be-deallocated"><a class="header" href="#pitfall-1-using-unowned-when-object-might-be-deallocated">Pitfall 1: Using Unowned When Object Might Be Deallocated</a></h3>
<pre><code class="language-swift">class ViewController {
    unowned let delegate: MyDelegate  // ‚ùå Crashes if delegate deallocated first
}

// Fix: Use weak
class ViewController {
    weak var delegate: MyDelegate?  // ‚úÖ Safe
}
</code></pre>
<h3 id="pitfall-2-strong-delegate-references"><a class="header" href="#pitfall-2-strong-delegate-references">Pitfall 2: Strong Delegate References</a></h3>
<pre><code class="language-swift">protocol DataSourceDelegate: AnyObject {
    func didUpdate()
}

class DataSource {
    var delegate: DataSourceDelegate?  // ‚ùå Should be weak!
}

// Fix:
class DataSource {
    weak var delegate: DataSourceDelegate?  // ‚úÖ Correct
}
</code></pre>
<h3 id="pitfall-3-closures-capturing-self"><a class="header" href="#pitfall-3-closures-capturing-self">Pitfall 3: Closures Capturing Self</a></h3>
<pre><code class="language-swift">class ViewController {
    var name = &quot;VC&quot;
    
    func setup() {
        someAsyncCall {
            print(self.name)  // ‚ùå Strong capture
        }
    }
}

// Fix:
func setup() {
    someAsyncCall { [weak self] in
        print(self?.name ?? &quot;&quot;)  // ‚úÖ Weak capture
    }
}
</code></pre>
<h2 id="-interview-tips-2"><a class="header" href="#-interview-tips-2">üé§ Interview Tips</a></h2>
<p><strong>Question</strong>: &quot;What's the difference between weak and unowned?&quot;</p>
<p><strong>Answer</strong>: </p>
<blockquote>
<p>&quot;Both weak and unowned don't increase the reference count, preventing retain cycles. The key difference is that weak is optional and automatically becomes nil when the object is deallocated, while unowned is non-optional and will crash if you try to access it after deallocation.</p>
<p>I use weak for delegates and optional relationships where the object might not exist. I use unowned when I'm certain the object will outlive the reference, like a child object referencing its parent that owns it.&quot;</p>
</blockquote>
<h2 id="-practice-challenge-2"><a class="header" href="#-practice-challenge-2">üèãÔ∏è Practice Challenge</a></h2>
<p>Create a <code>Node</code> class for a linked list where each node has a <code>next</code> (strong) and <code>previous</code> (weak) reference. Demonstrate that nodes are properly deallocated.</p>
<details>
<summary>Solution</summary>
<pre><code class="language-swift">class Node {
    let value: Int
    var next: Node?
    weak var previous: Node?
    
    init(value: Int) {
        self.value = value
        print(&quot;Node \(value) created&quot;)
    }
    
    deinit {
        print(&quot;Node \(value) deallocated&quot;)
    }
}

// Test
var head: Node? = Node(value: 1)
var second: Node? = Node(value: 2)
var third: Node? = Node(value: 3)

head?.next = second
second?.previous = head
second?.next = third
third?.previous = second

// Break the chain
head = nil
second = nil
third = nil
// All nodes deallocated properly
</code></pre>
</details>
<h2 id="-mastery-checklist-3"><a class="header" href="#-mastery-checklist-3">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Know when to use strong, weak, unowned</li>
<li><input disabled="" type="checkbox"/>
Understand reference counting impact</li>
<li><input disabled="" type="checkbox"/>
Can prevent retain cycles</li>
<li><input disabled="" type="checkbox"/>
Know weak is optional, unowned is not</li>
<li><input disabled="" type="checkbox"/>
Can identify when to use each in code</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="swift/./05-retain-cycles.html">Q5: Retain Cycles ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q5-what-causes-retain-cycles"><a class="header" href="#q5-what-causes-retain-cycles">Q5: What Causes Retain Cycles</a></h1>
<h2 id="-the-answer-3"><a class="header" href="#-the-answer-3">üéØ The Answer</a></h2>
<p>A retain cycle occurs when two or more objects hold strong references to each other, preventing ARC from deallocating them. Common causes: parent-child relationships, closures capturing self, delegates with strong references.</p>
<h2 id="-deep-dive-3"><a class="header" href="#-deep-dive-3">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">// RETAIN CYCLE EXAMPLE
class Parent {
    var child: Child?
    deinit { print(&quot;Parent deallocated&quot;) }
}

class Child {
    var parent: Parent?  // ‚ùå Strong reference creates cycle
    deinit { print(&quot;Child deallocated&quot;) }
}

var parent: Parent? = Parent()
var child: Child? = Child()
parent?.child = child
child?.parent = parent

parent = nil
child = nil
// ‚ùå Nothing prints - memory leak!

// FIX: Use weak
class Child {
    weak var parent: Parent?  // ‚úÖ Breaks the cycle
}
</code></pre>
<h3 id="common-scenarios"><a class="header" href="#common-scenarios">Common Scenarios</a></h3>
<p><strong>1. Closure Retain Cycles</strong></p>
<pre><code class="language-swift">class ViewController {
    var completion: (() -&gt; Void)?
    
    func setup() {
        completion = {
            self.view.backgroundColor = .red  // ‚ùå Captures self strongly
        }
    }
}

// Fix:
completion = { [weak self] in
    self?.view.backgroundColor = .red  // ‚úÖ
}
</code></pre>
<p><strong>2. Delegate Retain Cycles</strong></p>
<pre><code class="language-swift">protocol Delegate: AnyObject {}

class Manager {
    var delegate: Delegate?  // ‚ùå Should be weak
}

// Fix:
weak var delegate: Delegate?  // ‚úÖ
</code></pre>
<p><strong>3. Timer Retain Cycles</strong></p>
<pre><code class="language-swift">class ViewController {
    var timer: Timer?
    
    func startTimer() {
        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { _ in
            self.update()  // ‚ùå Timer retains self
        }
    }
}

// Fix:
timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
    self?.update()  // ‚úÖ
}
</code></pre>
<h2 id="-common-pitfalls-4"><a class="header" href="#-common-pitfalls-4">‚ö†Ô∏è Common Pitfalls</a></h2>
<p><strong>Pitfall</strong>: Forgetting to invalidate timers</p>
<pre><code class="language-swift">deinit {
    timer?.invalidate()  // ‚úÖ Must invalidate
}
</code></pre>
<h2 id="-interview-tips-3"><a class="header" href="#-interview-tips-3">üé§ Interview Tips</a></h2>
<p>&quot;Retain cycles happen when objects hold strong references to each other. The most common cases are closures capturing self, delegates, and parent-child relationships. I prevent them by using weak or unowned references, and always use [weak self] in closures that might outlive the object.&quot;</p>
<h2 id="-mastery-checklist-4"><a class="header" href="#-mastery-checklist-4">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Can identify retain cycles</li>
<li><input disabled="" type="checkbox"/>
Know how to break cycles</li>
<li><input disabled="" type="checkbox"/>
Understand closure capture</li>
<li><input disabled="" type="checkbox"/>
Know delegate best practices</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="swift/./06-property-wrappers.html">Q6: Property Wrappers ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q6-property-wrappers"><a class="header" href="#q6-property-wrappers">Q6: Property Wrappers</a></h1>
<h2 id="-the-answer-4"><a class="header" href="#-the-answer-4">üéØ The Answer</a></h2>
<p>Property wrappers add reusable behavior to properties using <code>@propertyWrapper</code>. They wrap a value and add logic for getting/setting. Examples: <code>@State</code>, <code>@Published</code>, <code>@UserDefault</code>.</p>
<h2 id="-deep-dive-4"><a class="header" href="#-deep-dive-4">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">@propertyWrapper
struct Capitalized {
    private var value: String = &quot;&quot;
    
    var wrappedValue: String {
        get { value }
        set { value = newValue.capitalized }
    }
    
    init(wrappedValue: String) {
        self.value = wrappedValue.capitalized
    }
}

// Usage
struct User {
    @Capitalized var name: String
}

var user = User(name: &quot;john&quot;)
print(user.name)  // &quot;John&quot;
user.name = &quot;jane&quot;
print(user.name)  // &quot;Jane&quot;
</code></pre>
<h3 id="built-in-property-wrappers"><a class="header" href="#built-in-property-wrappers">Built-in Property Wrappers</a></h3>
<p><strong>SwiftUI:</strong></p>
<ul>
<li><code>@State</code>: Local view state</li>
<li><code>@Binding</code>: Two-way binding</li>
<li><code>@StateObject</code>: Observable object owner</li>
<li><code>@ObservedObject</code>: Observable object observer</li>
<li><code>@EnvironmentObject</code>: Shared environment object</li>
<li><code>@Environment</code>: System environment values</li>
</ul>
<p><strong>Combine:</strong></p>
<ul>
<li><code>@Published</code>: Publishes value changes</li>
</ul>
<h3 id="custom-examples"><a class="header" href="#custom-examples">Custom Examples</a></h3>
<p><strong>@UserDefault</strong></p>
<pre><code class="language-swift">@propertyWrapper
struct UserDefault&lt;T&gt; {
    let key: String
    let defaultValue: T
    
    var wrappedValue: T {
        get {
            UserDefaults.standard.object(forKey: key) as? T ?? defaultValue
        }
        set {
            UserDefaults.standard.set(newValue, forKey: key)
        }
    }
}

// Usage
struct Settings {
    @UserDefault(key: &quot;username&quot;, defaultValue: &quot;Guest&quot;)
    var username: String
}
</code></pre>
<p><strong>@Clamped</strong></p>
<pre><code class="language-swift">@propertyWrapper
struct Clamped&lt;Value: Comparable&gt; {
    private var value: Value
    private let range: ClosedRange&lt;Value&gt;
    
    var wrappedValue: Value {
        get { value }
        set { value = min(max(range.lowerBound, newValue), range.upperBound) }
    }
    
    init(wrappedValue: Value, _ range: ClosedRange&lt;Value&gt;) {
        self.range = range
        self.value = min(max(range.lowerBound, wrappedValue), range.upperBound)
    }
}

struct Game {
    @Clamped(0...100) var health = 100
}
</code></pre>
<h2 id="-interview-tips-4"><a class="header" href="#-interview-tips-4">üé§ Interview Tips</a></h2>
<p>&quot;Property wrappers let me extract common property logic into reusable components. For example, @State in SwiftUI automatically triggers view updates when the value changes. I can create custom wrappers for things like UserDefaults, validation, or clamping values to ranges.&quot;</p>
<h2 id="-mastery-checklist-5"><a class="header" href="#-mastery-checklist-5">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Can create property wrappers</li>
<li><input disabled="" type="checkbox"/>
Know SwiftUI property wrappers</li>
<li><input disabled="" type="checkbox"/>
Understand wrappedValue</li>
<li><input disabled="" type="checkbox"/>
Can use projectedValue</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="swift/./07-codable.html">Q7: Codable ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q7-codable"><a class="header" href="#q7-codable">Q7: Codable</a></h1>
<h2 id="-the-answer-5"><a class="header" href="#-the-answer-5">üéØ The Answer</a></h2>
<p>Protocol for encoding/decoding, combines Encodable + Decodable</p>
<h2 id="-deep-dive-5"><a class="header" href="#-deep-dive-5">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">// Example code demonstrating the concept
</code></pre>
<h2 id="-common-pitfalls-5"><a class="header" href="#-common-pitfalls-5">‚ö†Ô∏è Common Pitfalls</a></h2>
<p>Common mistakes and how to avoid them.</p>
<h2 id="-interview-tips-5"><a class="header" href="#-interview-tips-5">üé§ Interview Tips</a></h2>
<p>How to answer this confidently in an interview.</p>
<h2 id="-practice-challenge-3"><a class="header" href="#-practice-challenge-3">üèãÔ∏è Practice Challenge</a></h2>
<p>Hands-on coding challenge to prove mastery.</p>
<details>
<summary>Solution</summary>
<pre><code class="language-swift">// Solution code
</code></pre>
</details>
<h2 id="-mastery-checklist-6"><a class="header" href="#-mastery-checklist-6">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Understand core concept</li>
<li><input disabled="" type="checkbox"/>
Can write code examples</li>
<li><input disabled="" type="checkbox"/>
Can explain to others</li>
</ul>
<hr />
<p><strong>Next</strong>: Next question ‚Üí</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q8-map-flatmap-compactmap"><a class="header" href="#q8-map-flatmap-compactmap">Q8: Map, FlatMap, CompactMap</a></h1>
<h2 id="-the-answer-6"><a class="header" href="#-the-answer-6">üéØ The Answer</a></h2>
<p>map transforms, flatMap flattens, compactMap removes nils</p>
<h2 id="-deep-dive-6"><a class="header" href="#-deep-dive-6">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">// Example code demonstrating the concept
</code></pre>
<h2 id="-common-pitfalls-6"><a class="header" href="#-common-pitfalls-6">‚ö†Ô∏è Common Pitfalls</a></h2>
<p>Common mistakes and how to avoid them.</p>
<h2 id="-interview-tips-6"><a class="header" href="#-interview-tips-6">üé§ Interview Tips</a></h2>
<p>How to answer this confidently in an interview.</p>
<h2 id="-practice-challenge-4"><a class="header" href="#-practice-challenge-4">üèãÔ∏è Practice Challenge</a></h2>
<p>Hands-on coding challenge to prove mastery.</p>
<details>
<summary>Solution</summary>
<pre><code class="language-swift">// Solution code
</code></pre>
</details>
<h2 id="-mastery-checklist-7"><a class="header" href="#-mastery-checklist-7">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Understand core concept</li>
<li><input disabled="" type="checkbox"/>
Can write code examples</li>
<li><input disabled="" type="checkbox"/>
Can explain to others</li>
</ul>
<hr />
<p><strong>Next</strong>: Next question ‚Üí</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q9-generics"><a class="header" href="#q9-generics">Q9: Generics</a></h1>
<h2 id="-the-answer-7"><a class="header" href="#-the-answer-7">üéØ The Answer</a></h2>
<p>Write flexible, reusable code that works with any type</p>
<h2 id="-deep-dive-7"><a class="header" href="#-deep-dive-7">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">// Example code demonstrating the concept
</code></pre>
<h2 id="-common-pitfalls-7"><a class="header" href="#-common-pitfalls-7">‚ö†Ô∏è Common Pitfalls</a></h2>
<p>Common mistakes and how to avoid them.</p>
<h2 id="-interview-tips-7"><a class="header" href="#-interview-tips-7">üé§ Interview Tips</a></h2>
<p>How to answer this confidently in an interview.</p>
<h2 id="-practice-challenge-5"><a class="header" href="#-practice-challenge-5">üèãÔ∏è Practice Challenge</a></h2>
<p>Hands-on coding challenge to prove mastery.</p>
<details>
<summary>Solution</summary>
<pre><code class="language-swift">// Solution code
</code></pre>
</details>
<h2 id="-mastery-checklist-8"><a class="header" href="#-mastery-checklist-8">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Understand core concept</li>
<li><input disabled="" type="checkbox"/>
Can write code examples</li>
<li><input disabled="" type="checkbox"/>
Can explain to others</li>
</ul>
<hr />
<p><strong>Next</strong>: Next question ‚Üí</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q10-protocols"><a class="header" href="#q10-protocols">Q10: Protocols</a></h1>
<h2 id="-the-answer-8"><a class="header" href="#-the-answer-8">üéØ The Answer</a></h2>
<p>A protocol defines a blueprint of methods, properties, and requirements that types must implement. It specifies &quot;what&quot; without &quot;how&quot; - enabling polymorphism, composition, and testability.</p>
<h2 id="-deep-dive-8"><a class="header" href="#-deep-dive-8">üìñ Deep Dive</a></h2>
<h3 id="basic-protocol"><a class="header" href="#basic-protocol">Basic Protocol</a></h3>
<pre><code class="language-swift">protocol Drawable {
    var color: String { get set }
    var lineWidth: Double { get }
    func draw()
}

struct Circle: Drawable {
    var color: String
    let lineWidth: Double = 2.0
    
    func draw() {
        print(&quot;Drawing \(color) circle with width \(lineWidth)&quot;)
    }
}

struct Rectangle: Drawable {
    var color: String
    var lineWidth: Double
    
    func draw() {
        print(&quot;Drawing \(color) rectangle&quot;)
    }
}

// Polymorphism
let shapes: [Drawable] = [
    Circle(color: &quot;red&quot;),
    Rectangle(color: &quot;blue&quot;, lineWidth: 3.0)
]

shapes.forEach { $0.draw() }
</code></pre>
<h3 id="property-requirements"><a class="header" href="#property-requirements">Property Requirements</a></h3>
<pre><code class="language-swift">protocol Vehicle {
    var speed: Double { get set }  // Read-write
    var maxSpeed: Double { get }   // Read-only
    static var wheelCount: Int { get }  // Type property
}

struct Car: Vehicle {
    var speed: Double
    let maxSpeed: Double = 200.0  // Can be let for get-only
    static let wheelCount = 4
}
</code></pre>
<h3 id="method-requirements"><a class="header" href="#method-requirements">Method Requirements</a></h3>
<pre><code class="language-swift">protocol Resettable {
    mutating func reset()  // mutating for value types
    func configure()
}

struct Counter: Resettable {
    var count = 0
    
    mutating func reset() {  // Must be mutating
        count = 0
    }
    
    func configure() {
        print(&quot;Configured&quot;)
    }
}

class Timer: Resettable {
    var seconds = 0
    
    func reset() {  // No mutating needed for classes
        seconds = 0
    }
    
    func configure() {
        print(&quot;Timer configured&quot;)
    }
}
</code></pre>
<h3 id="initializer-requirements"><a class="header" href="#initializer-requirements">Initializer Requirements</a></h3>
<pre><code class="language-swift">protocol Identifiable {
    var id: String { get }
    init(id: String)
}

struct User: Identifiable {
    let id: String
    // Initializer automatically satisfies requirement
}

class Product: Identifiable {
    let id: String
    required init(id: String) {  // required for classes
        self.id = id
    }
}

class SpecialProduct: Product {
    let name: String
    
    required init(id: String) {  // Must override with required
        self.name = &quot;Special&quot;
        super.init(id: id)
    }
}
</code></pre>
<h3 id="protocol-inheritance"><a class="header" href="#protocol-inheritance">Protocol Inheritance</a></h3>
<pre><code class="language-swift">protocol Identifiable {
    var id: String { get }
}

protocol Nameable {
    var name: String { get }
}

protocol Timestamped {
    var createdAt: Date { get }
}

protocol Entity: Identifiable, Nameable, Timestamped {
    // Inherits all requirements
}

struct User: Entity {
    let id: String
    let name: String
    let createdAt: Date
}
</code></pre>
<h3 id="class-only-protocols"><a class="header" href="#class-only-protocols">Class-Only Protocols</a></h3>
<pre><code class="language-swift">protocol Delegate: AnyObject {  // Only classes can conform
    func didUpdate()
}

class Manager {
    weak var delegate: Delegate?  // Can use weak
}
</code></pre>
<h3 id="protocol-extensions"><a class="header" href="#protocol-extensions">Protocol Extensions</a></h3>
<pre><code class="language-swift">protocol Greetable {
    var name: String { get }
    func greet()
    func farewell()
}

extension Greetable {
    // Default implementation
    func greet() {
        print(&quot;Hello, \(name)!&quot;)
    }
    
    func farewell() {
        print(&quot;Goodbye, \(name)!&quot;)
    }
}

struct Person: Greetable {
    let name: String
    // greet() and farewell() provided by extension
}

struct Robot: Greetable {
    let name: String
    
    // Can override default
    func greet() {
        print(&quot;BEEP BOOP. I AM \(name.uppercased())&quot;)
    }
}
</code></pre>
<h3 id="protocol-composition"><a class="header" href="#protocol-composition">Protocol Composition</a></h3>
<pre><code class="language-swift">protocol Codable: Encodable, Decodable {}  // Type alias

func save&lt;T: Codable &amp; Identifiable&gt;(_ item: T) {
    // T must conform to both Codable and Identifiable
}

// Using typealias
typealias Saveable = Codable &amp; Identifiable
func save&lt;T: Saveable&gt;(_ item: T) {
    // Same as above
}

// Inline composition
func process(_ item: Codable &amp; Equatable &amp; Hashable) {
    // Multiple protocol requirements
}
</code></pre>
<h3 id="conditional-conformance"><a class="header" href="#conditional-conformance">Conditional Conformance</a></h3>
<pre><code class="language-swift">extension Array: Equatable where Element: Equatable {
    // Array is Equatable only if Element is Equatable
}

let numbers = [1, 2, 3]
let sameNumbers = [1, 2, 3]
print(numbers == sameNumbers)  // true

extension Optional: Encodable where Wrapped: Encodable {
    // Optional is Encodable if Wrapped is Encodable
}
</code></pre>
<h3 id="protocol-with-associated-types-preview"><a class="header" href="#protocol-with-associated-types-preview">Protocol with Associated Types (Preview)</a></h3>
<pre><code class="language-swift">protocol Container {
    associatedtype Item
    var count: Int { get }
    mutating func append(_ item: Item)
}

struct IntStack: Container {
    typealias Item = Int  // Can be inferred
    private var items: [Int] = []
    
    var count: Int { items.count }
    
    mutating func append(_ item: Int) {
        items.append(item)
    }
}
</code></pre>
<h2 id="-common-pitfalls-8"><a class="header" href="#-common-pitfalls-8">‚ö†Ô∏è Common Pitfalls</a></h2>
<h3 id="pitfall-1-forgetting-mutating-for-value-types"><a class="header" href="#pitfall-1-forgetting-mutating-for-value-types">Pitfall 1: Forgetting <code>mutating</code> for Value Types</a></h3>
<pre><code class="language-swift">protocol Resettable {
    func reset()  // ‚ùå Won't work for structs that modify self
}

struct Counter: Resettable {
    var count = 0
    func reset() {  // ‚ùå Error: cannot assign to property
        count = 0
    }
}

// Fix:
protocol Resettable {
    mutating func reset()  // ‚úÖ
}
</code></pre>
<h3 id="pitfall-2-strong-delegate-references-1"><a class="header" href="#pitfall-2-strong-delegate-references-1">Pitfall 2: Strong Delegate References</a></h3>
<pre><code class="language-swift">protocol Delegate {  // ‚ùå Not class-only
    func didUpdate()
}

class Manager {
    var delegate: Delegate?  // ‚ùå Can't use weak
}

// Fix:
protocol Delegate: AnyObject {  // ‚úÖ Class-only
    func didUpdate()
}

class Manager {
    weak var delegate: Delegate?  // ‚úÖ Can use weak
}
</code></pre>
<h3 id="pitfall-3-protocol-extension-vs-requirement"><a class="header" href="#pitfall-3-protocol-extension-vs-requirement">Pitfall 3: Protocol Extension vs Requirement</a></h3>
<pre><code class="language-swift">protocol Greetable {
    func greet()
}

extension Greetable {
    func greet() {
        print(&quot;Hello&quot;)
    }
}

struct Person: Greetable {
    func greet() {
        print(&quot;Hi there!&quot;)
    }
}

let person: Greetable = Person()
person.greet()  // &quot;Hi there!&quot; - uses Person's implementation

// But watch out:
extension Greetable {
    func wave() {  // Not in protocol requirement
        print(&quot;üëã&quot;)
    }
}

struct Robot: Greetable {
    func greet() { print(&quot;BEEP&quot;) }
    func wave() { print(&quot;ü§ñ&quot;) }
}

let robot: Greetable = Robot()
robot.wave()  // &quot;üëã&quot; - uses extension, not Robot's implementation!
</code></pre>
<h2 id="-interview-tips-8"><a class="header" href="#-interview-tips-8">üé§ Interview Tips</a></h2>
<p><strong>Question</strong>: &quot;What are protocols and why use them?&quot;</p>
<p><strong>Answer</strong>:</p>
<blockquote>
<p>&quot;Protocols define contracts that types must fulfill - they specify what methods and properties a type must have without dictating how to implement them. This enables polymorphism, where I can treat different types uniformly if they conform to the same protocol.</p>
<p>I use protocols for dependency injection, making code testable, and enabling composition over inheritance. For example, instead of inheriting from a base class, I can have a struct conform to multiple protocols. Protocol extensions let me provide default implementations, reducing boilerplate.&quot;</p>
</blockquote>
<p><strong>Follow-up</strong>: &quot;Protocol vs abstract class?&quot;</p>
<p><strong>Answer</strong>:</p>
<blockquote>
<p>&quot;Swift doesn't have abstract classes, but protocols are more powerful anyway. Protocols support multiple conformance while classes only support single inheritance. Protocols work with structs, enums, and classes, while abstract classes would only work with classes. And protocol extensions provide default implementations similar to abstract class methods.&quot;</p>
</blockquote>
<h2 id="-practice-challenge-6"><a class="header" href="#-practice-challenge-6">üèãÔ∏è Practice Challenge</a></h2>
<p>Create a <code>DataStore</code> protocol that:</p>
<ol>
<li>Has an associated type <code>Item</code></li>
<li>Requires <code>save(_:)</code>, <code>fetch(id:)</code>, and <code>delete(id:)</code> methods</li>
<li>Provides a default <code>fetchAll()</code> implementation</li>
<li>Implement it for <code>UserStore</code> and <code>ProductStore</code></li>
</ol>
<details>
<summary>Solution</summary>
<pre><code class="language-swift">protocol DataStore {
    associatedtype Item: Identifiable
    
    func save(_ item: Item)
    func fetch(id: String) -&gt; Item?
    func delete(id: String)
}

extension DataStore {
    // Default implementation
    func fetchAll() -&gt; [Item] {
        // Would need storage mechanism
        []
    }
}

struct User: Identifiable {
    let id: String
    let name: String
}

struct UserStore: DataStore {
    typealias Item = User
    private var storage: [String: User] = [:]
    
    mutating func save(_ item: User) {
        storage[item.id] = item
    }
    
    func fetch(id: String) -&gt; User? {
        storage[id]
    }
    
    mutating func delete(id: String) {
        storage.removeValue(forKey: id)
    }
}

struct Product: Identifiable {
    let id: String
    let name: String
    let price: Double
}

struct ProductStore: DataStore {
    private var storage: [String: Product] = [:]
    
    mutating func save(_ item: Product) {
        storage[item.id] = item
    }
    
    func fetch(id: String) -&gt; Product? {
        storage[id]
    }
    
    mutating func delete(id: String) {
        storage.removeValue(forKey: id)
    }
}
</code></pre>
</details>
<h2 id="-mastery-checklist-9"><a class="header" href="#-mastery-checklist-9">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Can define protocols with properties and methods</li>
<li><input disabled="" type="checkbox"/>
Understand protocol inheritance</li>
<li><input disabled="" type="checkbox"/>
Know when to use <code>mutating</code></li>
<li><input disabled="" type="checkbox"/>
Can create protocol extensions</li>
<li><input disabled="" type="checkbox"/>
Understand protocol composition</li>
<li><input disabled="" type="checkbox"/>
Know class-only protocols (AnyObject)</li>
<li><input disabled="" type="checkbox"/>
Can use protocols for polymorphism</li>
</ul>
<h2 id="-quick-self-test-1"><a class="header" href="#-quick-self-test-1">üß† Quick Self-Test</a></h2>
<ol>
<li>Can structs conform to protocols? <strong>Yes</strong></li>
<li>Can protocols have default implementations? <strong>Yes, via extensions</strong></li>
<li>What's <code>AnyObject</code> for? <strong>Class-only protocols</strong></li>
<li>Can protocols inherit from multiple protocols? <strong>Yes</strong></li>
<li>Do classes need <code>mutating</code>? <strong>No</strong></li>
</ol>
<hr />
<p><strong>Next</strong>: <a href="swift/./11-protocol-vs-class.html">Q11: Protocol vs Class Inheritance ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q11-protocol-vs-class-inheritance"><a class="header" href="#q11-protocol-vs-class-inheritance">Q11: Protocol vs Class Inheritance</a></h1>
<h2 id="-the-answer-9"><a class="header" href="#-the-answer-9">üéØ The Answer</a></h2>
<p><strong>Protocols</strong>: Multiple adoption, no default implementation (unless extension), works with all types
<strong>Classes</strong>: Single inheritance, provides implementation, classes only</p>
<h2 id="-deep-dive-9"><a class="header" href="#-deep-dive-9">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">// PROTOCOLS - Multiple Adoption
protocol Flyable {
    func fly()
}

protocol Swimmable {
    func swim()
}

struct Duck: Flyable, Swimmable {  // ‚úÖ Multiple protocols
    func fly() { print(&quot;Duck flying&quot;) }
    func swim() { print(&quot;Duck swimming&quot;) }
}

// CLASSES - Single Inheritance
class Animal {
    func breathe() { print(&quot;Breathing&quot;) }
}

class Mammal: Animal {
    func nurse() { print(&quot;Nursing&quot;) }
}

class Dog: Mammal {  // ‚úÖ Inherits from Mammal (and Animal)
    func bark() { print(&quot;Barking&quot;) }
}

// class Cat: Mammal, Animal { }  // ‚ùå Can't inherit from multiple classes
</code></pre>
<h3 id="key-differences-1"><a class="header" href="#key-differences-1">Key Differences</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Protocol</th><th>Class Inheritance</th></tr></thead><tbody>
<tr><td>Multiple</td><td>‚úÖ Yes</td><td>‚ùå No (single only)</td></tr>
<tr><td>Value Types</td><td>‚úÖ Yes</td><td>‚ùå No</td></tr>
<tr><td>Implementation</td><td>Extension only</td><td>‚úÖ Yes</td></tr>
<tr><td>Override</td><td>No concept</td><td>‚úÖ Yes</td></tr>
<tr><td>Polymorphism</td><td>‚úÖ Yes</td><td>‚úÖ Yes</td></tr>
</tbody></table>
</div>
<h3 id="when-to-use-protocols"><a class="header" href="#when-to-use-protocols">When to Use Protocols</a></h3>
<pre><code class="language-swift">// Composition over inheritance
protocol Purchasable {
    var price: Double { get }
}

protocol Downloadable {
    func download()
}

protocol Streamable {
    func stream()
}

struct Movie: Purchasable, Downloadable, Streamable {
    let price: Double
    func download() { }
    func stream() { }
}

struct Song: Purchasable, Downloadable, Streamable {
    let price: Double
    func download() { }
    func stream() { }
}
</code></pre>
<h3 id="when-to-use-class-inheritance"><a class="header" href="#when-to-use-class-inheritance">When to Use Class Inheritance</a></h3>
<pre><code class="language-swift">// Shared implementation
class UIView {
    var frame: CGRect
    func draw() { /* complex drawing */ }
}

class UIButton: UIView {
    var title: String
    // Inherits frame and draw()
}

class UILabel: UIView {
    var text: String
    // Inherits frame and draw()
}
</code></pre>
<h2 id="-interview-tips-9"><a class="header" href="#-interview-tips-9">üé§ Interview Tips</a></h2>
<p>&quot;Protocols enable multiple conformance and work with value types, making them more flexible than class inheritance. I use protocols for capabilities and behaviors, and class inheritance when I need to share implementation. Swift favors protocol-oriented programming because it's more composable and testable.&quot;</p>
<h2 id="-mastery-checklist-10"><a class="header" href="#-mastery-checklist-10">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Know protocols allow multiple adoption</li>
<li><input disabled="" type="checkbox"/>
Understand single inheritance limitation</li>
<li><input disabled="" type="checkbox"/>
Can choose appropriate approach</li>
<li><input disabled="" type="checkbox"/>
Know composition over inheritance</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="swift/./12-associated-types.html">Q12: Associated Types ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q12-associated-types-in-protocols"><a class="header" href="#q12-associated-types-in-protocols">Q12: Associated Types in Protocols</a></h1>
<h2 id="-the-answer-10"><a class="header" href="#-the-answer-10">üéØ The Answer</a></h2>
<p>Associated types are placeholder types in protocols, defined by conforming types. They're like generics for protocols, enabling type-safe, flexible protocol definitions.</p>
<h2 id="-deep-dive-10"><a class="header" href="#-deep-dive-10">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">protocol Container {
    associatedtype Item  // Placeholder type
    
    var count: Int { get }
    mutating func append(_ item: Item)
    subscript(i: Int) -&gt; Item { get }
}

struct IntStack: Container {
    typealias Item = Int  // Define the associated type
    
    private var items: [Int] = []
    
    var count: Int {
        items.count
    }
    
    mutating func append(_ item: Int) {
        items.append(item)
    }
    
    subscript(i: Int) -&gt; Int {
        items[i]
    }
}

struct StringStack: Container {
    // Item inferred as String
    private var items: [String] = []
    
    var count: Int { items.count }
    
    mutating func append(_ item: String) {
        items.append(item)
    }
    
    subscript(i: Int) -&gt; String {
        items[i]
    }
}
</code></pre>
<h3 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h3>
<pre><code class="language-swift">protocol Container {
    associatedtype Item
    mutating func append(_ item: Item)
}

struct Stack: Container {
    private var items: [Int] = []
    
    mutating func append(_ item: Int) {  // Item inferred as Int
        items.append(item)
    }
}
</code></pre>
<h3 id="constraints-on-associated-types"><a class="header" href="#constraints-on-associated-types">Constraints on Associated Types</a></h3>
<pre><code class="language-swift">protocol SortableContainer {
    associatedtype Item: Comparable  // Item must be Comparable
    var items: [Item] { get }
    func sorted() -&gt; [Item]
}

struct NumberContainer: SortableContainer {
    let items: [Int]
    
    func sorted() -&gt; [Int] {
        items.sorted()
    }
}
</code></pre>
<h3 id="using-associated-types-in-functions"><a class="header" href="#using-associated-types-in-functions">Using Associated Types in Functions</a></h3>
<pre><code class="language-swift">// Can't use protocol with associated type directly
// func process(_ container: Container) { }  // ‚ùå Error

// Use generics instead
func process&lt;C: Container&gt;(_ container: C) where C.Item == Int {
    // C is any Container where Item is Int
}

// Or use type erasure
struct AnyContainer&lt;T&gt;: Container {
    typealias Item = T
    
    private let _count: () -&gt; Int
    private let _append: (T) -&gt; Void
    private let _subscript: (Int) -&gt; T
    
    init&lt;C: Container&gt;(_ container: C) where C.Item == T {
        var mutableContainer = container
        _count = { container.count }
        _append = { mutableContainer.append($0) }
        _subscript = { container[$0] }
    }
    
    var count: Int { _count() }
    mutating func append(_ item: T) { _append(item) }
    subscript(i: Int) -&gt; T { _subscript(i) }
}
</code></pre>
<h2 id="-interview-tips-10"><a class="header" href="#-interview-tips-10">üé§ Interview Tips</a></h2>
<p>&quot;Associated types let protocols work with different types while maintaining type safety. They're like generics for protocols. For example, Array's Element is an associated type. I use them when a protocol needs to work with a type that conforming types will define.&quot;</p>
<h2 id="-mastery-checklist-11"><a class="header" href="#-mastery-checklist-11">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Understand associated types</li>
<li><input disabled="" type="checkbox"/>
Can constrain associated types</li>
<li><input disabled="" type="checkbox"/>
Know type inference</li>
<li><input disabled="" type="checkbox"/>
Understand generic constraints</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="swift/./13-extensions.html">Q13: Extensions ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q13-extensions"><a class="header" href="#q13-extensions">Q13: Extensions</a></h1>
<h2 id="-the-answer-11"><a class="header" href="#-the-answer-11">üéØ The Answer</a></h2>
<p>Extensions add functionality to existing types without subclassing or modifying source code. Can add methods, computed properties, initializers, and protocol conformance.</p>
<h2 id="-deep-dive-11"><a class="header" href="#-deep-dive-11">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">// Add methods to existing types
extension String {
    func trimmed() -&gt; String {
        trimmingCharacters(in: .whitespacesAndNewlines)
    }
    
    var isEmail: Bool {
        contains(&quot;@&quot;) &amp;&amp; contains(&quot;.&quot;)
    }
}

&quot;  hello  &quot;.trimmed()  // &quot;hello&quot;
&quot;test@example.com&quot;.isEmail  // true

// Add computed properties
extension Int {
    var squared: Int {
        self * self
    }
    
    var isEven: Bool {
        self % 2 == 0
    }
}

5.squared  // 25
4.isEven   // true

// Add initializers
extension UIColor {
    convenience init(hex: String) {
        // Parse hex string
        self.init(red: 1, green: 0, blue: 0, alpha: 1)
    }
}

// Protocol conformance
extension Array: Identifiable where Element: Identifiable {
    var id: String {
        map { $0.id }.joined()
    }
}

// Conditional extensions
extension Array where Element: Numeric {
    func sum() -&gt; Element {
        reduce(0, +)
    }
}

[1, 2, 3].sum()  // 6
</code></pre>
<h2 id="-interview-tips-11"><a class="header" href="#-interview-tips-11">üé§ Interview Tips</a></h2>
<p>&quot;Extensions let me add functionality to types I don't own, like String or Int. I use them to organize code, add protocol conformance, and provide convenience methods. They can't add stored properties or override existing methods.&quot;</p>
<h2 id="-mastery-checklist-12"><a class="header" href="#-mastery-checklist-12">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Can create extensions</li>
<li><input disabled="" type="checkbox"/>
Know limitations (no stored properties)</li>
<li><input disabled="" type="checkbox"/>
Understand conditional extensions</li>
<li><input disabled="" type="checkbox"/>
Can add protocol conformance</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="swift/./14-static-vs-class.html">Q14: Static vs Class Methods ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q14-static-vs-class-methods"><a class="header" href="#q14-static-vs-class-methods">Q14: Static vs Class Methods</a></h1>
<h2 id="-the-answer-12"><a class="header" href="#-the-answer-12">üéØ The Answer</a></h2>
<p><strong>static</strong>: Cannot be overridden in subclasses
<strong>class</strong>: Can be overridden in subclasses (classes only)</p>
<h2 id="-deep-dive-12"><a class="header" href="#-deep-dive-12">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">class Vehicle {
    static func staticMethod() {
        print(&quot;Vehicle static&quot;)
    }
    
    class func classMethod() {
        print(&quot;Vehicle class&quot;)
    }
}

class Car: Vehicle {
    // Can't override static
    // override static func staticMethod() { }  // ‚ùå Error
    
    // Can override class
    override class func classMethod() {
        print(&quot;Car class&quot;)
    }
}

Vehicle.staticMethod()  // &quot;Vehicle static&quot;
Car.staticMethod()      // &quot;Vehicle static&quot; (inherited)

Vehicle.classMethod()   // &quot;Vehicle class&quot;
Car.classMethod()       // &quot;Car class&quot; (overridden)

// Static properties
struct Config {
    static let apiKey = &quot;abc123&quot;
    static var baseURL = &quot;https://api.example.com&quot;
}

Config.apiKey  // &quot;abc123&quot;
</code></pre>
<h2 id="-interview-tips-12"><a class="header" href="#-interview-tips-12">üé§ Interview Tips</a></h2>
<p>&quot;Static methods and properties belong to the type, not instances. Static can't be overridden, while class methods can be overridden in subclasses. I use static for utility functions and constants, class for factory methods that subclasses might customize.&quot;</p>
<h2 id="-mastery-checklist-13"><a class="header" href="#-mastery-checklist-13">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Know static vs class difference</li>
<li><input disabled="" type="checkbox"/>
Understand override capability</li>
<li><input disabled="" type="checkbox"/>
Can use type properties</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="swift/./15-closures.html">Q15: Closures ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q15-closures"><a class="header" href="#q15-closures">Q15: Closures</a></h1>
<h2 id="-the-answer-13"><a class="header" href="#-the-answer-13">üéØ The Answer</a></h2>
<p>Closures are self-contained blocks of code that can capture and store references to variables and constants from their surrounding context.</p>
<h2 id="-deep-dive-13"><a class="header" href="#-deep-dive-13">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">// Closure syntax
let greet = { (name: String) -&gt; String in
    return &quot;Hello, \(name)&quot;
}

greet(&quot;Alice&quot;)  // &quot;Hello, Alice&quot;

// Trailing closure
[1, 2, 3].map { $0 * 2 }  // [2, 4, 6]

// Capturing values
func makeIncrementer(amount: Int) -&gt; () -&gt; Int {
    var total = 0
    return {
        total += amount
        return total
    }
}

let incrementByTwo = makeIncrementer(amount: 2)
incrementByTwo()  // 2
incrementByTwo()  // 4

// Closure as parameter
func performOperation(_ operation: (Int, Int) -&gt; Int) {
    let result = operation(5, 3)
    print(result)
}

performOperation { $0 + $1 }  // 8
</code></pre>
<h2 id="-interview-tips-13"><a class="header" href="#-interview-tips-13">üé§ Interview Tips</a></h2>
<p>&quot;Closures are like anonymous functions that can capture values from their context. They're used for callbacks, completion handlers, and functional programming. Swift has three types: global functions, nested functions, and closure expressions.&quot;</p>
<h2 id="-mastery-checklist-14"><a class="header" href="#-mastery-checklist-14">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Understand closure syntax</li>
<li><input disabled="" type="checkbox"/>
Know value capturing</li>
<li><input disabled="" type="checkbox"/>
Can use trailing closures</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="swift/./16-escaping-closures.html">Q16: Escaping vs Non-Escaping ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q16-escaping-vs-non-escaping"><a class="header" href="#q16-escaping-vs-non-escaping">Q16: Escaping vs Non-Escaping</a></h1>
<h2 id="-the-answer-14"><a class="header" href="#-the-answer-14">üéØ The Answer</a></h2>
<p><strong>Non-escaping</strong> (default): Closure executed before function returns
<strong>Escaping</strong> (@escaping): Closure can outlive the function, stored or called later</p>
<h2 id="-deep-dive-14"><a class="header" href="#-deep-dive-14">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">// Non-escaping (default)
func performSync(completion: () -&gt; Void) {
    completion()  // Called immediately
}  // completion can't be used after return

// Escaping
func performAsync(completion: @escaping () -&gt; Void) {
    DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
        completion()  // Called after function returns
    }
}

// Stored closure must be escaping
class ViewController {
    var completion: (() -&gt; Void)?
    
    func setup(completion: @escaping () -&gt; Void) {
        self.completion = completion  // Stored
    }
}

// Escaping requires explicit self
class Manager {
    var name = &quot;Manager&quot;
    
    func start(completion: @escaping () -&gt; Void) {
        DispatchQueue.main.async {
            print(self.name)  // Must use self
            completion()
        }
    }
}
</code></pre>
<h2 id="-interview-tips-14"><a class="header" href="#-interview-tips-14">üé§ Interview Tips</a></h2>
<p>&quot;Non-escaping closures are executed before the function returns, so they're safer and more efficient. Escaping closures can outlive the function - used for async operations, stored properties, or callbacks. Escaping closures require explicit self to avoid accidental retain cycles.&quot;</p>
<h2 id="-mastery-checklist-15"><a class="header" href="#-mastery-checklist-15">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Know default is non-escaping</li>
<li><input disabled="" type="checkbox"/>
Understand when to use @escaping</li>
<li><input disabled="" type="checkbox"/>
Know self requirement</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="swift/./17-autoclosure.html">Q17: Autoclosure ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q17-autoclosure"><a class="header" href="#q17-autoclosure">Q17: Autoclosure</a></h1>
<h2 id="-the-answer-15"><a class="header" href="#-the-answer-15">üéØ The Answer</a></h2>
<p>@autoclosure automatically wraps an expression in a closure, delaying its evaluation. Used for short-circuit evaluation and lazy execution.</p>
<h2 id="-deep-dive-15"><a class="header" href="#-deep-dive-15">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">// Without autoclosure
func assert(_ condition: () -&gt; Bool, message: String) {
    if !condition() {
        print(message)
    }
}

assert({ 2 + 2 == 4 }, message: &quot;Math broken&quot;)  // Verbose

// With autoclosure
func assert(_ condition: @autoclosure () -&gt; Bool, message: String) {
    if !condition() {
        print(message)
    }
}

assert(2 + 2 == 4, message: &quot;Math broken&quot;)  // Clean!

// Real-world: Optional coalescing
func ?? &lt;T&gt;(optional: T?, defaultValue: @autoclosure () -&gt; T) -&gt; T {
    if let value = optional {
        return value
    }
    return defaultValue()  // Only evaluated if needed
}

let name: String? = nil
let result = name ?? expensiveOperation()  // Only called if name is nil
</code></pre>
<h2 id="-mastery-checklist-16"><a class="header" href="#-mastery-checklist-16">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Understand @autoclosure</li>
<li><input disabled="" type="checkbox"/>
Know lazy evaluation</li>
<li><input disabled="" type="checkbox"/>
Can use appropriately</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="swift/./18-inout.html">Q18: Inout ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q18-inout"><a class="header" href="#q18-inout">Q18: Inout</a></h1>
<h2 id="-the-answer-16"><a class="header" href="#-the-answer-16">üéØ The Answer</a></h2>
<p>inout allows functions to modify parameter values, passing by reference instead of by value. Creates copy-in, copy-out behavior.</p>
<h2 id="-deep-dive-16"><a class="header" href="#-deep-dive-16">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">func increment(_ value: inout Int) {
    value += 1
}

var number = 5
increment(&amp;number)  // Must use &amp;
print(number)  // 6

// Swap function
func swap&lt;T&gt;(_ a: inout T, _ b: inout T) {
    let temp = a
    a = b
    b = temp
}

var x = 1, y = 2
swap(&amp;x, &amp;y)
print(x, y)  // 2, 1

// Can't pass constants or literals
// increment(&amp;5)  // ‚ùå Error
let constant = 10
// increment(&amp;constant)  // ‚ùå Error
</code></pre>
<h2 id="-mastery-checklist-17"><a class="header" href="#-mastery-checklist-17">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Understand inout keyword</li>
<li><input disabled="" type="checkbox"/>
Know &amp; syntax</li>
<li><input disabled="" type="checkbox"/>
Can modify parameters</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="swift/./19-optional-chaining.html">Q19: Optional Chaining ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q19-optional-chaining"><a class="header" href="#q19-optional-chaining">Q19: Optional Chaining</a></h1>
<h2 id="-the-answer-17"><a class="header" href="#-the-answer-17">üéØ The Answer</a></h2>
<p>Optional chaining queries optional properties, methods, and subscripts with ?. Returns nil if any part of the chain is nil.</p>
<h2 id="-deep-dive-17"><a class="header" href="#-deep-dive-17">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">struct Address {
    var street: String
}

struct Person {
    var address: Address?
}

let person = Person(address: nil)

// Optional chaining
let street = person.address?.street  // nil (String?)

// vs Forced unwrapping
// let street = person.address!.street  // ‚ùå Crash!

// Chaining multiple levels
struct Company {
    var ceo: Person?
}

let company = Company(ceo: Person(address: Address(street: &quot;Main St&quot;)))
let ceoStreet = company.ceo?.address?.street  // Optional(&quot;Main St&quot;)

// Method calls
class Counter {
    var count = 0
    func increment() { count += 1 }
}

var counter: Counter? = Counter()
counter?.increment()  // Calls if not nil
</code></pre>
<h2 id="-mastery-checklist-18"><a class="header" href="#-mastery-checklist-18">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Understand ? operator</li>
<li><input disabled="" type="checkbox"/>
Know nil propagation</li>
<li><input disabled="" type="checkbox"/>
Can chain multiple levels</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="swift/./20-properties.html">Q20: Computed vs Stored Properties ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q20-computed-vs-stored-properties"><a class="header" href="#q20-computed-vs-stored-properties">Q20: Computed vs Stored Properties</a></h1>
<h2 id="-the-answer-18"><a class="header" href="#-the-answer-18">üéØ The Answer</a></h2>
<p><strong>Stored</strong>: Hold values in memory
<strong>Computed</strong>: Calculate values on access, no storage</p>
<h2 id="-deep-dive-18"><a class="header" href="#-deep-dive-18">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">struct Rectangle {
    // Stored properties
    var width: Double
    var height: Double
    
    // Computed property
    var area: Double {
        width * height
    }
    
    // Computed with getter and setter
    var perimeter: Double {
        get {
            2 * (width + height)
        }
        set {
            // newValue is implicit
            let side = newValue / 4
            width = side
            height = side
        }
    }
}

var rect = Rectangle(width: 10, height: 5)
print(rect.area)  // 50 (calculated)
rect.perimeter = 40  // Sets width and height

// Property observers
struct StepCounter {
    var steps: Int = 0 {
        willSet {
            print(&quot;About to set to \(newValue)&quot;)
        }
        didSet {
            print(&quot;Changed from \(oldValue) to \(steps)&quot;)
        }
    }
}

// Lazy stored property
class DataManager {
    lazy var data: [String] = {
        print(&quot;Loading data...&quot;)
        return [&quot;Item 1&quot;, &quot;Item 2&quot;]
    }()
}

let manager = DataManager()
// &quot;Loading data...&quot; not printed yet
print(manager.data)  // Now it loads
</code></pre>
<h2 id="-mastery-checklist-19"><a class="header" href="#-mastery-checklist-19">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Know stored vs computed</li>
<li><input disabled="" type="checkbox"/>
Understand property observers</li>
<li><input disabled="" type="checkbox"/>
Can use lazy properties</li>
</ul>
<hr />
<p><strong>Congratulations!</strong> You've completed Swift &amp; Language (Q1-20)</p>
<p><strong>Next Section</strong>: <a href="swift/../concurrency/21-gcd.html">Q21: Concurrency - GCD ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q21-gcd-grand-central-dispatch"><a class="header" href="#q21-gcd-grand-central-dispatch">Q21: GCD (Grand Central Dispatch)</a></h1>
<h2 id="-the-answer-19"><a class="header" href="#-the-answer-19">üéØ The Answer</a></h2>
<p>GCD is Apple's low-level API for managing concurrent operations using dispatch queues. It abstracts thread management and optimizes task execution.</p>
<h2 id="-deep-dive-19"><a class="header" href="#-deep-dive-19">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">// Main queue - UI updates
DispatchQueue.main.async {
    self.label.text = &quot;Updated&quot;
}

// Global queues - background work
DispatchQueue.global(qos: .userInitiated).async {
    // Heavy computation
    let result = processData()
    
    DispatchQueue.main.async {
        self.updateUI(with: result)
    }
}

// Quality of Service levels
DispatchQueue.global(qos: .userInteractive).async { }  // Highest priority
DispatchQueue.global(qos: .userInitiated).async { }    // High priority
DispatchQueue.global(qos: .default).async { }          // Default
DispatchQueue.global(qos: .utility).async { }          // Low priority
DispatchQueue.global(qos: .background).async { }       // Lowest priority

// Custom queue
let queue = DispatchQueue(label: &quot;com.app.myqueue&quot;)
queue.async {
    print(&quot;Custom queue work&quot;)
}

// Concurrent queue
let concurrent = DispatchQueue(label: &quot;com.app.concurrent&quot;, attributes: .concurrent)
concurrent.async { print(&quot;Task 1&quot;) }
concurrent.async { print(&quot;Task 2&quot;) }  // Can run simultaneously
</code></pre>
<h2 id="-interview-tips-15"><a class="header" href="#-interview-tips-15">üé§ Interview Tips</a></h2>
<p>&quot;GCD manages concurrent execution using queues. Main queue for UI, global queues for background work. I choose QoS based on task priority - userInteractive for UI-related, background for non-urgent tasks.&quot;</p>
<h2 id="-mastery-checklist-20"><a class="header" href="#-mastery-checklist-20">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Understand dispatch queues</li>
<li><input disabled="" type="checkbox"/>
Know QoS levels</li>
<li><input disabled="" type="checkbox"/>
Can switch between queues</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="concurrency/./22-sync-async.html">Q22: Sync vs Async ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q22-sync-vs-async"><a class="header" href="#q22-sync-vs-async">Q22: Sync vs Async</a></h1>
<h2 id="-the-answer-20"><a class="header" href="#-the-answer-20">üéØ The Answer</a></h2>
<p><strong>sync</strong>: Blocks current thread until task completes
<strong>async</strong>: Returns immediately, task runs in background</p>
<h2 id="-deep-dive-20"><a class="header" href="#-deep-dive-20">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">let queue = DispatchQueue(label: &quot;com.app.queue&quot;)

// ASYNC - Non-blocking
print(&quot;1&quot;)
queue.async {
    print(&quot;2&quot;)
}
print(&quot;3&quot;)
// Output: 1, 3, 2

// SYNC - Blocking
print(&quot;1&quot;)
queue.sync {
    print(&quot;2&quot;)
}
print(&quot;3&quot;)
// Output: 1, 2, 3

// Real-world: Network call
func fetchData(completion: @escaping (Data?) -&gt; Void) {
    DispatchQueue.global().async {
        // Network request
        let data = downloadData()
        
        DispatchQueue.main.async {
            completion(data)
        }
    }
}

// Barrier for thread-safe writes
let concurrent = DispatchQueue(label: &quot;queue&quot;, attributes: .concurrent)

concurrent.async {
    // Read operation
}

concurrent.async(flags: .barrier) {
    // Write operation - waits for reads, blocks new reads
}
</code></pre>
<h2 id="-mastery-checklist-21"><a class="header" href="#-mastery-checklist-21">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Know sync blocks</li>
<li><input disabled="" type="checkbox"/>
Understand async returns immediately</li>
<li><input disabled="" type="checkbox"/>
Can use barriers</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="concurrency/./23-queues.html">Q23: Serial vs Concurrent Queues ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q23-serial-vs-concurrent-queues"><a class="header" href="#q23-serial-vs-concurrent-queues">Q23: Serial vs Concurrent Queues</a></h1>
<h2 id="-the-answer-21"><a class="header" href="#-the-answer-21">üéØ The Answer</a></h2>
<p><strong>Serial</strong>: Executes one task at a time, in order
<strong>Concurrent</strong>: Executes multiple tasks simultaneously</p>
<h2 id="-deep-dive-21"><a class="header" href="#-deep-dive-21">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">// Serial queue (default)
let serial = DispatchQueue(label: &quot;com.app.serial&quot;)
serial.async { print(&quot;Task 1&quot;) }
serial.async { print(&quot;Task 2&quot;) }
serial.async { print(&quot;Task 3&quot;) }
// Output: Task 1, Task 2, Task 3 (in order)

// Concurrent queue
let concurrent = DispatchQueue(label: &quot;com.app.concurrent&quot;, attributes: .concurrent)
concurrent.async { print(&quot;Task 1&quot;) }
concurrent.async { print(&quot;Task 2&quot;) }
concurrent.async { print(&quot;Task 3&quot;) }
// Output: Order not guaranteed

// Thread-safe counter with serial queue
class Counter {
    private var value = 0
    private let queue = DispatchQueue(label: &quot;counter&quot;)
    
    func increment() {
        queue.async {
            self.value += 1
        }
    }
    
    func getValue() -&gt; Int {
        queue.sync {
            return value
        }
    }
}
</code></pre>
<h2 id="-mastery-checklist-22"><a class="header" href="#-mastery-checklist-22">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Know serial executes in order</li>
<li><input disabled="" type="checkbox"/>
Understand concurrent parallelism</li>
<li><input disabled="" type="checkbox"/>
Can choose appropriate queue</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="concurrency/./24-race-conditions.html">Q24: Race Conditions ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q24-race-conditions"><a class="header" href="#q24-race-conditions">Q24: Race Conditions</a></h1>
<h2 id="-the-answer-22"><a class="header" href="#-the-answer-22">üéØ The Answer</a></h2>
<p>A race condition occurs when multiple threads access shared data simultaneously, causing unpredictable results. Fixed with synchronization (serial queues, locks, actors).</p>
<h2 id="-deep-dive-22"><a class="header" href="#-deep-dive-22">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">// RACE CONDITION
class UnsafeCounter {
    var count = 0
    
    func increment() {
        count += 1  // ‚ùå Not thread-safe
    }
}

let counter = UnsafeCounter()
DispatchQueue.concurrentPerform(iterations: 1000) { _ in
    counter.increment()
}
print(counter.count)  // Not 1000! Race condition

// FIX 1: Serial Queue
class SafeCounter {
    private var count = 0
    private let queue = DispatchQueue(label: &quot;counter&quot;)
    
    func increment() {
        queue.sync {
            count += 1
        }
    }
}

// FIX 2: Actor (Swift 5.5+)
actor ActorCounter {
    var count = 0
    
    func increment() {
        count += 1  // Automatically synchronized
    }
}
</code></pre>
<h2 id="-mastery-checklist-23"><a class="header" href="#-mastery-checklist-23">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Can identify race conditions</li>
<li><input disabled="" type="checkbox"/>
Know synchronization methods</li>
<li><input disabled="" type="checkbox"/>
Understand thread safety</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="concurrency/./25-deadlocks.html">Q25: Deadlocks ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q25-deadlocks"><a class="header" href="#q25-deadlocks">Q25: Deadlocks</a></h1>
<h2 id="-the-answer-23"><a class="header" href="#-the-answer-23">üéØ The Answer</a></h2>
<p>A deadlock occurs when two or more threads wait for each other indefinitely. Common cause: nested sync calls on same queue.</p>
<h2 id="-deep-dive-23"><a class="header" href="#-deep-dive-23">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">// DEADLOCK EXAMPLE
let queue = DispatchQueue(label: &quot;queue&quot;)

queue.sync {
    print(&quot;Outer&quot;)
    queue.sync {  // ‚ùå DEADLOCK!
        print(&quot;Inner&quot;)
    }
}

// FIX: Use async or different queue
queue.async {
    print(&quot;Outer&quot;)
    queue.async {  // ‚úÖ Works
        print(&quot;Inner&quot;)
    }
}

// Avoid on main queue
DispatchQueue.main.sync {  // ‚ùå Deadlock if called from main
    print(&quot;This will hang&quot;)
}
</code></pre>
<h2 id="-mastery-checklist-24"><a class="header" href="#-mastery-checklist-24">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Understand deadlock causes</li>
<li><input disabled="" type="checkbox"/>
Can avoid nested sync</li>
<li><input disabled="" type="checkbox"/>
Know prevention strategies</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="concurrency/./26-dispatch-group.html">Q26: DispatchGroup ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q26-dispatchgroup"><a class="header" href="#q26-dispatchgroup">Q26: DispatchGroup</a></h1>
<h2 id="-the-answer-24"><a class="header" href="#-the-answer-24">üéØ The Answer</a></h2>
<p>DispatchGroup coordinates multiple async tasks, notifying when all complete.</p>
<h2 id="-deep-dive-24"><a class="header" href="#-deep-dive-24">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">let group = DispatchGroup()

// Method 1: enter/leave
group.enter()
fetchUser { user in
    print(&quot;Got user&quot;)
    group.leave()
}

group.enter()
fetchPosts { posts in
    print(&quot;Got posts&quot;)
    group.leave()
}

group.notify(queue: .main) {
    print(&quot;All done!&quot;)
}

// Method 2: Pass to async
let queue = DispatchQueue.global()
queue.async(group: group) {
    // Task 1
}
queue.async(group: group) {
    // Task 2
}

// Wait (blocks)
group.wait()  // Waits until all complete
</code></pre>
<h2 id="-mastery-checklist-25"><a class="header" href="#-mastery-checklist-25">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Can use enter/leave</li>
<li><input disabled="" type="checkbox"/>
Know notify callback</li>
<li><input disabled="" type="checkbox"/>
Understand wait blocking</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="concurrency/./27-operation-queue.html">Q27: OperationQueue ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q27-operationqueue"><a class="header" href="#q27-operationqueue">Q27: OperationQueue</a></h1>
<h2 id="-the-answer-25"><a class="header" href="#-the-answer-25">üéØ The Answer</a></h2>
<p>OperationQueue is higher-level than GCD, supporting dependencies, cancellation, and priorities.</p>
<h2 id="-deep-dive-25"><a class="header" href="#-deep-dive-25">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">let queue = OperationQueue()

// Block operation
queue.addOperation {
    print(&quot;Task&quot;)
}

// Dependencies
let op1 = BlockOperation { print(&quot;First&quot;) }
let op2 = BlockOperation { print(&quot;Second&quot;) }
op2.addDependency(op1)  // op2 waits for op1

queue.addOperations([op1, op2], waitUntilFinished: false)

// Cancellation
let operation = BlockOperation {
    for i in 1...100 {
        if operation.isCancelled { return }
        print(i)
    }
}
queue.addOperation(operation)
operation.cancel()

// Max concurrent
queue.maxConcurrentOperationCount = 2
</code></pre>
<h2 id="-mastery-checklist-26"><a class="header" href="#-mastery-checklist-26">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Know dependencies</li>
<li><input disabled="" type="checkbox"/>
Can cancel operations</li>
<li><input disabled="" type="checkbox"/>
Understand vs GCD</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="concurrency/./28-async-await.html">Q28: Async-Await ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q28-async-await"><a class="header" href="#q28-async-await">Q28: Async-Await</a></h1>
<h2 id="-the-answer-26"><a class="header" href="#-the-answer-26">üéØ The Answer</a></h2>
<p>Modern concurrency syntax. async marks functions as asynchronous, await suspends execution until result ready.</p>
<h2 id="-deep-dive-26"><a class="header" href="#-deep-dive-26">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">// Async function
func fetchUser() async throws -&gt; User {
    let (data, _) = try await URLSession.shared.data(from: url)
    return try JSONDecoder().decode(User.self, from: data)
}

// Calling async
Task {
    do {
        let user = try await fetchUser()
        print(user.name)
    } catch {
        print(error)
    }
}

// Async let - parallel execution
func loadData() async {
    async let user = fetchUser()
    async let posts = fetchPosts()
    
    let (u, p) = await (user, posts)  // Wait for both
}

// MainActor for UI
@MainActor
func updateUI() {
    label.text = &quot;Updated&quot;  // Guaranteed on main thread
}
</code></pre>
<h2 id="-mastery-checklist-27"><a class="header" href="#-mastery-checklist-27">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Understand async/await</li>
<li><input disabled="" type="checkbox"/>
Can use Task</li>
<li><input disabled="" type="checkbox"/>
Know async let</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="concurrency/./29-actors.html">Q29: Actors ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q29-actors"><a class="header" href="#q29-actors">Q29: Actors</a></h1>
<h2 id="-the-answer-27"><a class="header" href="#-the-answer-27">üéØ The Answer</a></h2>
<p>Actors are reference types that protect mutable state from data races. Only one task can access actor state at a time.</p>
<h2 id="-deep-dive-27"><a class="header" href="#-deep-dive-27">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">actor Counter {
    var value = 0
    
    func increment() {
        value += 1  // Thread-safe automatically
    }
    
    func getValue() -&gt; Int {
        value
    }
}

// Usage
let counter = Counter()

Task {
    await counter.increment()  // Must use await
    let value = await counter.getValue()
}

// Nonisolated for synchronous access
actor DataStore {
    private var data: [String] = []
    
    nonisolated let id: String  // Can access without await
    
    init(id: String) {
        self.id = id
    }
}
</code></pre>
<h2 id="-mastery-checklist-28"><a class="header" href="#-mastery-checklist-28">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Understand actor isolation</li>
<li><input disabled="" type="checkbox"/>
Know await requirement</li>
<li><input disabled="" type="checkbox"/>
Can use nonisolated</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="concurrency/./30-main-actor.html">Q30: MainActor ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q30-mainactor"><a class="header" href="#q30-mainactor">Q30: MainActor</a></h1>
<h2 id="-the-answer-28"><a class="header" href="#-the-answer-28">üéØ The Answer</a></h2>
<p>MainActor is a global actor representing the main thread. Ensures UI updates happen on main thread.</p>
<h2 id="-deep-dive-28"><a class="header" href="#-deep-dive-28">üìñ Deep Dive</a></h2>
<pre><code class="language-swift">// Mark class
@MainActor
class ViewModel: ObservableObject {
    @Published var data: [String] = []
    
    func loadData() {
        // All methods run on main thread
    }
}

// Mark function
@MainActor
func updateUI() {
    label.text = &quot;Updated&quot;
}

// Switch to main
func fetchData() async {
    let data = await downloadData()
    
    await MainActor.run {
        self.updateUI(with: data)
    }
}

// SwiftUI views are @MainActor by default
struct ContentView: View {
    var body: some View {
        Text(&quot;Hello&quot;)  // Always on main thread
    }
}
</code></pre>
<h2 id="-mastery-checklist-29"><a class="header" href="#-mastery-checklist-29">‚úÖ Mastery Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Know MainActor purpose</li>
<li><input disabled="" type="checkbox"/>
Can annotate types/functions</li>
<li><input disabled="" type="checkbox"/>
Understand UI thread safety</li>
</ul>
<hr />
<p><strong>Congratulations!</strong> Completed Concurrency (Q21-Q30)</p>
<p><strong>Next Section</strong>: <a href="concurrency/../memory/31-arc-allocation.html">Q31: Memory Management ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q31-arc-memory-allocation"><a class="header" href="#q31-arc-memory-allocation">Q31: ARC Memory Allocation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q32-weak-references"><a class="header" href="#q32-weak-references">Q32: Weak References</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q33-unowned-references"><a class="header" href="#q33-unowned-references">Q33: Unowned References</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q34-closure-retain-cycles"><a class="header" href="#q34-closure-retain-cycles">Q34: Closure Retain Cycles</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q35-capture-lists"><a class="header" href="#q35-capture-lists">Q35: Capture Lists</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q36-memory-leaks"><a class="header" href="#q36-memory-leaks">Q36: Memory Leaks</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q37-instruments"><a class="header" href="#q37-instruments">Q37: Instruments</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q38-mvvm-retain-cycles"><a class="header" href="#q38-mvvm-retain-cycles">Q38: MVVM Retain Cycles</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q39-memory-warnings"><a class="header" href="#q39-memory-warnings">Q39: Memory Warnings</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q40-reference-counting"><a class="header" href="#q40-reference-counting">Q40: Reference Counting</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q41-uiviewcontroller-lifecycle"><a class="header" href="#q41-uiviewcontroller-lifecycle">Q41: UIViewController Lifecycle</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q42-app-lifecycle"><a class="header" href="#q42-app-lifecycle">Q42: App Lifecycle</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q43-frame-vs-bounds"><a class="header" href="#q43-frame-vs-bounds">Q43: Frame vs Bounds</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q44-auto-layout"><a class="header" href="#q44-auto-layout">Q44: Auto Layout</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q45-constraints-vs-frames"><a class="header" href="#q45-constraints-vs-frames">Q45: Constraints vs Frames</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q46-cell-reuse"><a class="header" href="#q46-cell-reuse">Q46: Cell Reuse</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q47-diffable-data-source"><a class="header" href="#q47-diffable-data-source">Q47: Diffable Data Source</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q48-compositional-layout"><a class="header" href="#q48-compositional-layout">Q48: Compositional Layout</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q49-swiftui-lifecycle"><a class="header" href="#q49-swiftui-lifecycle">Q49: SwiftUI Lifecycle</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q50-state-vs-binding"><a class="header" href="#q50-state-vs-binding">Q50: @State vs @Binding</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q51-observedobject-vs-stateobject"><a class="header" href="#q51-observedobject-vs-stateobject">Q51: @ObservedObject vs @StateObject</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q52-environment-values"><a class="header" href="#q52-environment-values">Q52: Environment Values</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q53-navigationstack"><a class="header" href="#q53-navigationstack">Q53: NavigationStack</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q54-swiftui-diff-engine"><a class="header" href="#q54-swiftui-diff-engine">Q54: SwiftUI Diff Engine</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q55-view-identity"><a class="header" href="#q55-view-identity">Q55: View Identity</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q56-lazy-stacks"><a class="header" href="#q56-lazy-stacks">Q56: Lazy Stacks</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q57-scroll-performance"><a class="header" href="#q57-scroll-performance">Q57: Scroll Performance</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q58-rendering-pipeline"><a class="header" href="#q58-rendering-pipeline">Q58: Rendering Pipeline</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q59-uikit-vs-swiftui"><a class="header" href="#q59-uikit-vs-swiftui">Q59: UIKit vs SwiftUI</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q60-mixing-uikit--swiftui"><a class="header" href="#q60-mixing-uikit--swiftui">Q60: Mixing UIKit + SwiftUI</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q61-urlsession-flow"><a class="header" href="#q61-urlsession-flow">Q61: URLSession Flow</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q62-datatask-vs-downloadtask"><a class="header" href="#q62-datatask-vs-downloadtask">Q62: DataTask vs DownloadTask</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q63-json-decoding"><a class="header" href="#q63-json-decoding">Q63: JSON Decoding</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q64-error-handling"><a class="header" href="#q64-error-handling">Q64: Error Handling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q65-http-caching"><a class="header" href="#q65-http-caching">Q65: HTTP Caching</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q66-urlrequests"><a class="header" href="#q66-urlrequests">Q66: URLRequests</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q67-rest-vs-graphql"><a class="header" href="#q67-rest-vs-graphql">Q67: REST vs GraphQL</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q68-status-codes"><a class="header" href="#q68-status-codes">Q68: Status Codes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q69-retry-mechanism"><a class="header" href="#q69-retry-mechanism">Q69: Retry Mechanism</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="q70-debouncing"><a class="header" href="#q70-debouncing">Q70: Debouncing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift--language-quiz"><a class="header" href="#swift--language-quiz">Swift &amp; Language Quiz</a></h1>
<p>Test your mastery of Swift fundamentals (Q1-Q20)</p>
<h2 id="-multiple-choice"><a class="header" href="#-multiple-choice">üìù Multiple Choice</a></h2>
<h3 id="question-1"><a class="header" href="#question-1">Question 1</a></h3>
<p>What happens when you assign a struct to another variable?</p>
<p>A) A reference is shared<br />
B) A copy is created<br />
C) A pointer is created<br />
D) Compiler error</p>
<details>
<summary>Answer</summary>
<p><strong>B) A copy is created</strong></p>
<p>Structs are value types, so assignment creates a complete copy.</p>
</details>
<hr />
<h3 id="question-2"><a class="header" href="#question-2">Question 2</a></h3>
<p>Which is true about ARC?</p>
<p>A) Works at runtime like garbage collection<br />
B) Only works with structs<br />
C) Inserts retain/release at compile time<br />
D) Requires manual memory management</p>
<details>
<summary>Answer</summary>
<p><strong>C) Inserts retain/release at compile time</strong></p>
<p>ARC is a compile-time feature that automatically manages reference counting.</p>
</details>
<hr />
<h3 id="question-3"><a class="header" href="#question-3">Question 3</a></h3>
<p>What's the output?</p>
<pre><code class="language-swift">class Box {
    var value: Int
    init(value: Int) { self.value = value }
}

let box = Box(value: 10)
box.value = 20
print(box.value)
</code></pre>
<p>A) Compiler error<br />
B) 10<br />
C) 20<br />
D) nil</p>
<details>
<summary>Answer</summary>
<p><strong>C) 20</strong></p>
<p><code>let</code> makes the reference constant, not the object's properties.</p>
</details>
<hr />
<h2 id="-code-challenges"><a class="header" href="#-code-challenges">üíª Code Challenges</a></h2>
<h3 id="challenge-1-fix-the-retain-cycle"><a class="header" href="#challenge-1-fix-the-retain-cycle">Challenge 1: Fix the Retain Cycle</a></h3>
<pre><code class="language-swift">class Parent {
    var child: Child?
    deinit { print(&quot;Parent gone&quot;) }
}

class Child {
    var parent: Parent?
    deinit { print(&quot;Child gone&quot;) }
}

var p: Parent? = Parent()
var c: Child? = Child()
p?.child = c
c?.parent = p
p = nil
c = nil
// Nothing prints! Fix it.
</code></pre>
<details>
<summary>Solution</summary>
<pre><code class="language-swift">class Parent {
    var child: Child?
    deinit { print(&quot;Parent gone&quot;) }
}

class Child {
    weak var parent: Parent?  // ‚úÖ Use weak
    deinit { print(&quot;Child gone&quot;) }
}
</code></pre>
</details>
<hr />
<h3 id="challenge-2-implement-a-generic-stack"><a class="header" href="#challenge-2-implement-a-generic-stack">Challenge 2: Implement a Generic Stack</a></h3>
<p>Create a generic <code>Stack&lt;T&gt;</code> with:</p>
<ul>
<li><code>push(_ item: T)</code></li>
<li><code>pop() -&gt; T?</code></li>
<li><code>peek() -&gt; T?</code></li>
<li><code>isEmpty: Bool</code></li>
</ul>
<details>
<summary>Solution</summary>
<pre><code class="language-swift">struct Stack&lt;T&gt; {
    private var items: [T] = []
    
    mutating func push(_ item: T) {
        items.append(item)
    }
    
    mutating func pop() -&gt; T? {
        items.popLast()
    }
    
    func peek() -&gt; T? {
        items.last
    }
    
    var isEmpty: Bool {
        items.isEmpty
    }
}

// Test
var stack = Stack&lt;Int&gt;()
stack.push(1)
stack.push(2)
print(stack.pop())  // Optional(2)
print(stack.peek()) // Optional(1)
</code></pre>
</details>
<hr />
<h3 id="challenge-3-protocol-with-associated-type"><a class="header" href="#challenge-3-protocol-with-associated-type">Challenge 3: Protocol with Associated Type</a></h3>
<p>Create a <code>Container</code> protocol with:</p>
<ul>
<li>Associated type <code>Item</code></li>
<li><code>add(_ item: Item)</code></li>
<li><code>count: Int</code></li>
</ul>
<p>Implement it for an <code>IntContainer</code>.</p>
<details>
<summary>Solution</summary>
<pre><code class="language-swift">protocol Container {
    associatedtype Item
    mutating func add(_ item: Item)
    var count: Int { get }
}

struct IntContainer: Container {
    typealias Item = Int
    private var items: [Int] = []
    
    mutating func add(_ item: Int) {
        items.append(item)
    }
    
    var count: Int {
        items.count
    }
}
</code></pre>
</details>
<hr />
<h2 id="-scenario-questions"><a class="header" href="#-scenario-questions">üéØ Scenario Questions</a></h2>
<h3 id="scenario-1-memory-leak-detective"><a class="header" href="#scenario-1-memory-leak-detective">Scenario 1: Memory Leak Detective</a></h3>
<p>You have a view controller that never deallocates. The code:</p>
<pre><code class="language-swift">class ProfileVC: UIViewController {
    var user: User?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        NetworkManager.shared.fetchUser { user in
            self.user = user
            self.updateUI()
        }
    }
    
    func updateUI() {
        // Update UI
    }
}
</code></pre>
<p><strong>Question</strong>: What's causing the leak and how do you fix it?</p>
<details>
<summary>Answer</summary>
<p>The closure captures <code>self</code> strongly. If <code>NetworkManager</code> holds onto the closure, it creates a retain cycle.</p>
<p><strong>Fix</strong>:</p>
<pre><code class="language-swift">NetworkManager.shared.fetchUser { [weak self] user in
    self?.user = user
    self?.updateUI()
}
</code></pre>
</details>
<hr />
<h2 id="-score-yourself"><a class="header" href="#-score-yourself">üìä Score Yourself</a></h2>
<ul>
<li><strong>0-5 correct</strong>: Review the Swift fundamentals section</li>
<li><strong>6-10 correct</strong>: Good foundation, practice more</li>
<li><strong>11-15 correct</strong>: Strong understanding</li>
<li><strong>16+ correct</strong>: Interview ready! üéâ</li>
</ul>
<hr />
<p><strong>Next</strong>: <a href="quizzes/./concurrency-quiz.html">Concurrency Quiz ‚Üí</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quiz"><a class="header" href="#quiz">Quiz</a></h1>
<h2 id="multiple-choice-questions"><a class="header" href="#multiple-choice-questions">Multiple Choice Questions</a></h2>
<h3 id="question-1-1"><a class="header" href="#question-1-1">Question 1</a></h3>
<p>[Question text]</p>
<p>A) Option A
B) Option B
C) Option C
D) Option D</p>
<details>
<summary>Answer</summary>
<p><strong>[Correct Answer]</strong></p>
<p>Explanation here.</p>
</details>
<hr />
<h2 id="code-challenges"><a class="header" href="#code-challenges">Code Challenges</a></h2>
<h3 id="challenge-1"><a class="header" href="#challenge-1">Challenge 1</a></h3>
<p>[Challenge description]</p>
<details>
<summary>Solution</summary>
<pre><code class="language-swift">// Solution code
</code></pre>
</details>
<hr />
<h2 id="score-yourself"><a class="header" href="#score-yourself">Score Yourself</a></h2>
<ul>
<li>8-10: Excellent</li>
<li>6-7: Good</li>
<li>4-5: Review needed</li>
<li>0-3: Study more</li>
</ul>
<hr />
<p><strong>Next Quiz</strong> ‚Üí</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quiz-1"><a class="header" href="#quiz-1">Quiz</a></h1>
<h2 id="multiple-choice-questions-1"><a class="header" href="#multiple-choice-questions-1">Multiple Choice Questions</a></h2>
<h3 id="question-1-2"><a class="header" href="#question-1-2">Question 1</a></h3>
<p>[Question text]</p>
<p>A) Option A
B) Option B
C) Option C
D) Option D</p>
<details>
<summary>Answer</summary>
<p><strong>[Correct Answer]</strong></p>
<p>Explanation here.</p>
</details>
<hr />
<h2 id="code-challenges-1"><a class="header" href="#code-challenges-1">Code Challenges</a></h2>
<h3 id="challenge-1-1"><a class="header" href="#challenge-1-1">Challenge 1</a></h3>
<p>[Challenge description]</p>
<details>
<summary>Solution</summary>
<pre><code class="language-swift">// Solution code
</code></pre>
</details>
<hr />
<h2 id="score-yourself-1"><a class="header" href="#score-yourself-1">Score Yourself</a></h2>
<ul>
<li>8-10: Excellent</li>
<li>6-7: Good</li>
<li>4-5: Review needed</li>
<li>0-3: Study more</li>
</ul>
<hr />
<p><strong>Next Quiz</strong> ‚Üí</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quiz-2"><a class="header" href="#quiz-2">Quiz</a></h1>
<h2 id="multiple-choice-questions-2"><a class="header" href="#multiple-choice-questions-2">Multiple Choice Questions</a></h2>
<h3 id="question-1-3"><a class="header" href="#question-1-3">Question 1</a></h3>
<p>[Question text]</p>
<p>A) Option A
B) Option B
C) Option C
D) Option D</p>
<details>
<summary>Answer</summary>
<p><strong>[Correct Answer]</strong></p>
<p>Explanation here.</p>
</details>
<hr />
<h2 id="code-challenges-2"><a class="header" href="#code-challenges-2">Code Challenges</a></h2>
<h3 id="challenge-1-2"><a class="header" href="#challenge-1-2">Challenge 1</a></h3>
<p>[Challenge description]</p>
<details>
<summary>Solution</summary>
<pre><code class="language-swift">// Solution code
</code></pre>
</details>
<hr />
<h2 id="score-yourself-2"><a class="header" href="#score-yourself-2">Score Yourself</a></h2>
<ul>
<li>8-10: Excellent</li>
<li>6-7: Good</li>
<li>4-5: Review needed</li>
<li>0-3: Study more</li>
</ul>
<hr />
<p><strong>Next Quiz</strong> ‚Üí</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quiz-3"><a class="header" href="#quiz-3">Quiz</a></h1>
<h2 id="multiple-choice-questions-3"><a class="header" href="#multiple-choice-questions-3">Multiple Choice Questions</a></h2>
<h3 id="question-1-4"><a class="header" href="#question-1-4">Question 1</a></h3>
<p>[Question text]</p>
<p>A) Option A
B) Option B
C) Option C
D) Option D</p>
<details>
<summary>Answer</summary>
<p><strong>[Correct Answer]</strong></p>
<p>Explanation here.</p>
</details>
<hr />
<h2 id="code-challenges-3"><a class="header" href="#code-challenges-3">Code Challenges</a></h2>
<h3 id="challenge-1-3"><a class="header" href="#challenge-1-3">Challenge 1</a></h3>
<p>[Challenge description]</p>
<details>
<summary>Solution</summary>
<pre><code class="language-swift">// Solution code
</code></pre>
</details>
<hr />
<h2 id="score-yourself-3"><a class="header" href="#score-yourself-3">Score Yourself</a></h2>
<ul>
<li>8-10: Excellent</li>
<li>6-7: Good</li>
<li>4-5: Review needed</li>
<li>0-3: Study more</li>
</ul>
<hr />
<p><strong>Next Quiz</strong> ‚Üí</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="final-challenge"><a class="header" href="#final-challenge">Final Challenge</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
